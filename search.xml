<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[js学习之事件模型]]></title>
      <url>%2F2017%2F03%2F10%2Fjs-dom%2F</url>
      <content type="text"><![CDATA[一直对JavaScript中的事件模型不是很清楚，特此记录学习笔记 DOM事件流Dom(文档对象模型)结构是一个树形结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程称为DOM事件流。 事件顺序有两种类型：事件捕获和事件冒泡 冒泡型事件（Event Bubbling）这是IE浏览器对事件模型的实现，也是最容易理解的。冒泡，顾名思义，事件像水中的气泡一样往上冒，直到顶端。从DOM树形结构上理解，就是事件由具有从属关系的最确定的目标元素一直传递到最不确定的目标元素。即从当前元素一层一层往外知道最顶层。 捕获型事件（Event Capturing）与冒泡型刚好相反，由DOM树最顶层元素一直到最精确的元素。 标准的事件转送模式（1）.在事件捕捉（Capturing）阶段，事件将沿着DOM树向下转送，目标节点的每一个祖先节点，直至目标节点。例如，若用户单击了一个超链接，则该单击事件将从document节点转送到html元素，body元素以及包含该链接的p元素。在此过程中，浏览器都会检测针对该事件的捕捉事件监听器，并且运行这件事件监听器。(2). 在目标（target）阶段，浏览器在查找到已经指定给目标事件的事件监听器之后，就会运行 该事件监听器。目标节点就是触发事件的DOM节点。例如，如果用户单击一个超链接，那么该链接就是目标节点（此时的目标节点实际上是超链接内的文本节点）。（3）.在冒泡（Bubbling）阶段，事件将沿着DOM树向上转送，再次逐个访问目标元素的祖先节点到document节点。该过程中的每一步。浏览器都将检测那些不是捕捉事件监听器的事件监听器，并执行它们。 并非所有的事件都经过冒泡阶段所有的事件都要经过捕捉阶段和目标阶段，但是有些事件会跳过冒泡阶段，例如让元素获得输入焦点的focus事件和失去输入焦点的blur事件都不会冒泡。 事件句柄和事件监听器事件句柄事件句柄（又称事件处理函数，DOM称之为事件监听函数），用于响应某个事件而调用的函数称为事件处理函数。每一个事件对应一个句柄，响应点击事件的函数是onclick事件处理函数，可以分配在HTML和JavaScript中。 HTML1&lt;a href="#" onclick="click"&gt;click me!&lt;/a&gt; JavaSript1234var link = document.getElementById("mylink");link.onclick=function()&#123; dosomething();&#125;; 事件监听器现在大多数浏览器都内置了一些更高级的事件处理方式，即事件监听器，这种处理方式就不受一个元素只能绑定一个事件句柄的限制。事件句柄和事件监听器最大的不同就是在使用事件句柄时一次只能插接一个事件句柄，但对于事件监听器，一次可以插接多个。 IE下的事件监听器1element.attachEvent("onevent",eventListener); 在IE中想要给一个元素的事件附加事件处理函数，必须调用attachEvent方法才能创建一个事件监听器。attachEvent方法允许外界注册该元素多个事件监听器。attachEvent方法接受两个参数，第一个参数是事件类型名（’on’开头），第二个参数是回调处理函数。注意：IE中用attachEvent注册的处理函数调用this指向不再是先前注册事件的元素，此时的this为window对象。用detachEvent方法即可移除，参数相同。 DOM标准下的事件监听器1234//标准语法element.addEventListener('event',eventListener,useCapture);//默认element.addEventListener('event',eventListener,false); addEventListener方法接受三个参数，第一个参数是事件类型名（没’on’开头），第二个参数是回调处理函数，第三个参数注明该处理函数在事件传递过程中是否调用捕获阶段，通常设置为false（为false时是冒泡），如果设置为true，就创建爱你一个捕捉事件监听器。用removeEventListener方法即可移除，参数必须完全相同（包括useCapture的值）。 跨浏览器的注册与移除元素事件监听器12345678910111213141516171819202122var Event = &#123; //注册 addHandler:function(element,type,handle)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handle,false); &#125;else if(element.attachEvent)&#123; element.attachEvent("on"+type,handle); &#125;else &#123; element["on"+type] = handle; &#125; &#125;, //移除 removeHandle:function()&#123; if(element.remoeEventListener)&#123; element.removeEventListener(type,handle,false); &#125;else if(element.detachEvent)&#123; element.detachEvent("on"+type,handle); &#125;else &#123; element["on"+type] = null; &#125; &#125;&#125;; 事件对象引用为了可以更好地处理事件，可以根据所发生的事件的特定属性来采取不同的操作。与事件模型类似，IE使用一个event的全局事件对象来处理对象（可以在全局变量window.event来访问），其它浏览器采用的W3C推荐的方式，使用独立的包含事件对象的参数传递。 12345678var EventUtil=&#123; getEvent:function(event)&#123; return event?event:window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;&#125;; 停止事件冒泡和阻止事件的默认行为停止事件冒泡和祖师事件的默认行为这两个概念非常重要吗，它们对复杂的应用程序处理非常有用。 停止事件冒泡停止事件冒泡，指停止冒泡型事件的进一步传递。在冒泡型时间传递中，如果在body处理停止事件传递后，位于上层的document的事件监听器就不再收到通知，不再被处理。 IE下的停止事件冒泡123function someHandle()&#123; window.event.cancelBubble = true; // 取消冒泡&#125; DOM标准下的停止事件冒泡123function someHandle(event)&#123; event.stopPropagation();&#125; 跨浏览器的停止事件冒泡12345678function someHandle(event)&#123; event=event || window.event; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 停止事件的默认行为停止事件的默认行为，指通常浏览器在事件传递并处理完后会执行与该事件相关联的默认动作。例如，表单中input type的属性是”submit”，点击后在事件传播完后，浏览器就自动提交表单。又例如，input元素的keydown事件发生并树立后，浏览器默认会将用户键入的字符自动追加到input元素中。 IE下的停止事件的默认行为123function someHandle()&#123; window.event.returnValue = false;&#125; DOM标准下的停止事件的默认行为123function someHandle(event)&#123; event.preventDefault();&#125; 跨浏览器的停止时间的默认行为12345678function someHandle(event)&#123; event = event || window.event; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 完整的事件处理兼容性函数123456789101112131415161718192021222324252627282930313233343536373839404142434445var EventUtil=&#123; //添加事件 addHandler:function(element,type,handle)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handle.false); &#125;else if(element.attachEvent)&#123; element.attachEvent("on"+type,handle); &#125;else &#123; element["on"+type]=handle; &#125; &#125;, //移除事件 removeHandler:function(element,type,handle)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handle,false); &#125;else if(element.detachEvent)&#123; element.detachEvent("on"+type,handle); &#125;else &#123; element["on"+type]=null; &#125; &#125;, //获取事件对象 getEvent:function(event)&#123; return event?event:window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, //停止冒泡 stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else &#123; event.cancelBubble=true; &#125; &#125;, //停止事件的默认行为 preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else &#123; event.returnValue=false; &#125; &#125;&#125;; 捕获型事件模型与冒泡型事件模型的应用场合捕获型事件模型的应用场合捕获型事件传递由最不精确的祖先元素一直到最精确的事件源元素，传递方式与操作系统中的全局快捷键与应用程序快捷键相似。当一个系统组合键发生时，如果注册了系统全局快捷键监听器，该事件就先被操作系统层捕获，全局监听器就先于应用程序快捷键监听器得到通知，也就是全局的先获得控制权，它有权阻止事件的进一步传递。所以捕获型事件模型适用于作全局范围内的监听，这里的全局是相对的全局，相对于某个顶层结点与该结点所有子孙结点形成的集合范围。例如你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器。12345678function globalClickListener(event)&#123; if(canEventPass == false)&#123; //取消事件的进一步向子节点传递和冒泡传递 event.stopPropagation(); //取消浏览器事件后的默认行为 event.preventDefault(); &#125;&#125; 冒泡型事件模型的应用场合在元素一些频繁触发的事件中，如onmousemove,onmouseover,onmouseout,如果明确事件处理后没必要进一步传递，那么就可以大胆的取消它。此外，对于子结点事件监听器的处理会对父层监听器处理造成负面影响的，也应该在子结点监听器中禁止事件进一步向上传递以消除影响。 123456789&lt;body onclick="alert('current is body');"&gt; &lt;div id="div0" onclick="alert('current is '+this.id)"&gt; &lt;div id="div1" onclick="alert('current is '+this.id)"&gt; &lt;div id="div2" onclick="alert('current is '+this.id)"&gt; &lt;div id="event_source" onclick="alert('current is '+this.id)" style="height:200px;width:200px;background-color:red;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 点击event_source时无论是DOM标准还是IE，直接写在HTML里的监听处理函数是事件冒泡传递时调用的，由最里层一直往上传递，先后出现current is event_sourcecurrent is div2current is div1current is div0current is body 添加以下片段12345var div2 = document.getElementById("div2");EventUtil.addHandler(div2,'click',function(event)&#123; event=EventUtil.getEvent(); EventUtil.stopPropagation(event);&#125;,false); 点击出现current is event_sourcecurrent is div2 在支持DOM标准的浏览器中，添加以下代码123document.body.addEventListener('click',function()&#123; event.stopPropagation();&#125;,true);//在捕获型传递调用 以上代码中的监听函数由于是捕获型传递时被调用的,所以点击event_source后,虽然事件源是id为event_source的元素,但捕获型选传递,从最顶层开始,body节点监听函数先被调用,并且取消了事件进一步向下传递,所以只会出现current is body 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之(原型)继承]]></title>
      <url>%2F2017%2F02%2F21%2Fentend%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》继承意味着复制操作，JavaScript(默认)不会复制对象属性。JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 创建一个关联对象12345678function Foo()&#123;&#125;function Bar()&#123;&#125;//ES6之前Bar.prototype = Object.create(Foo.prototype);//ES6Object.setPrototypeOf(Bar.prototype,Foo.prototype); Object.create()会创建一个新对象(这里指Bar.prototype)并把新对象内部的[[Prototype]]关联到指定的对象中(这里指Foo)。 [[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其它对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之对象]]></title>
      <url>%2F2017%2F02%2F20%2Fobject%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》 对象的定义 声明形式1234var obj=&#123; key1:value1, key2:value2&#125;; 构造形式12var obj = new Object();obj.key=value; 对象的类型 基本类型对象是JavaScript的基础，在JavaScrpit中一共有六种主要类型。 string boolean number null undefined object 内置对象一些基本类型对象的子类型，通常被成为内置对象。 String Number Boolean Object Function Array Date RegExp Error!!!在JavaScript中，它们只是一些内置函数，而不是类似于Java当中的类。!!!12345678910var str1 = "I am a string";console.log(typeof str1); // stringconsole.log(str1 instanceof String); // falsevar str2 = new String("I am a String");console.log(typeof str2); // objectconsole.log(str2 instanceof String); // true//检查str2对象Object.prototype.toString.call(str2); // [Object String] 对象的内容 访问对象的值12345var obj&#123; a : 2&#125;;console.log(obj.a); // 2console.log(obj["a"]); // 2 访问对象的值，需要使用 .操作符和[]操作符。.语法通常被成为属性访问，[]语法通常被成为键访问。 属性描述符ECMAScript5中定义了一个叫”属性描述符”的对象。123456789var obj=&#123;&#125;;Object.defineProperty(obj,"a"&#123; value:2, // 值 writable:true, // 是否可写 configurable:true, // 是否可配置 enumerable:true, // 是否可枚举 setter:function()&#123;&#125;, // 设置值 getter:function()&#123;&#125; // 获取值&#125;); Writablewritable 决定是否可以修改属性的值。123456789var obj = &#123;&#125;;Object.defineProperty(obj,"a",&#123; value:2, writable:false, configurable:true, enumerable:true&#125;);obj.a = 3;console.log(obj.a); // 2,无法修改值,在严格模式下会报TypeError错误 Configurable只要属性是可配置的，就可以使用defineProperty()方法来修改属性描述符12345678910111213141516171819202122var obj = &#123;&#125;;obj.a = 3;console.log(obj.a);Object.defineProperty(obj,"a",&#123; value:4, writable:true, configurable:false, writable:true&#125;);console.log(obj.a); // 4obj.a = 5;console.log(obj.a); // 5delete obj.a;console.log(obj.a); // 5，禁止删除这个属性Object.defineProperty(obj,"a",&#123; value:6, writable:true, configurable:true, writable:true&#125;); // TypeError,无法修改属性描述符 由此可见，把configurable修改为false是单向操作，无法撤销！ Enumerable控制对象的属性能否出现在属性枚举中，比如说for..in循环。12345678910111213141516var obj=&#123; a:2, b:3&#125;;for(let i in obj)&#123; console.log(i);&#125; // a bObject.defineProperty(obj,"a",&#123; value:2, writable:true, configurable:true, enumerable:false&#125;);for(let i in obj)&#123; console.log(i);&#125; // b Setter和Getter1234567891011121314var obj=&#123; get a()&#123; return this._a_; &#125; set a(value)&#123; this._a_ = value*2; &#125;&#125;;Object.defineProperty(obj,"b",&#123; get:function()&#123;return this.a*2&#125;,&#125;);obj.a=2;console.log(obj.a); // 4console.log(obj.b); // 8 禁止拓展禁止一个对象添属性并保留已有属性。123456var obj=&#123; a=2&#125;;Object.preventExtensions(obj); //禁止拓展obj.b=3;console.log(obj.b); // undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之this]]></title>
      <url>%2F2017%2F02%2F19%2Fthis%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》 绑定规则 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); // 2 默认绑定时,this指向全局对象。但是在严格模式下,全局对象无法使用默认绑定。123456function foo()&#123; "use strict"; console.log(this.a);&#125;var a=2;foo(); // Type Error:this is undefined 隐式绑定在一个对象内部创建包含一个指向函数的属性，并通过这个对象间接引用函数，从而把this隐式绑定到这个对象上。12345678function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;obj.f(); // 2 this绑定到obj对象 隐式丢失12345678910function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;var bar = obj.f;var a = "hello";bar(); // hello 隐式绑定的函数丢失绑定对象，应用默认绑定。 显式绑定使用 call() 和 apply() 方法，把this绑定到传进去的对象上1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a=2;&#125;foo.call(obj); // 2 与隐式绑定相同，显示绑定同样有着绑定丢失的情况但是显示绑定的一个变种可以解决这个问题 硬绑定12345678910function foo something(something)&#123; console.log(this.a,something); return this.a + something;&#125;var obj=&#123; a=2;&#125;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); //5 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar = new foo(2);console.log(bar.a); // 2 创建一个新对象并把它绑定到foo()调用的this上 优先级 显示绑定和隐式绑定12345678910111213141516function foo()&#123; console.log(this.a);&#125;var obj1=&#123; a:2, foo:foo&#125;;var obj2=&#123; a=3, foo:foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 可以看到，显示绑定优先级更高，在判断时应当先考虑是否可以应用显示绑定 new绑定和隐式绑定12345678910111213function foo(something)&#123; this.a=something;&#125;var obj1=&#123; foo:foo&#125;;obj1.foo(2);console.log(obj1.a); // 2var bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 可以看到，new绑定比隐式绑定优先级更高 new绑定和显示绑定123456789101112function foo(something)&#123; this.a=something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);consolo.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 可以看到，new绑定比显示绑定优先级更高 判断this顺序按照下面的顺序来判断this所应用的规则1.函数是否在用new中调用(new绑定) var bar = new foo(); 2.函数是否通过call、apply或者bind(硬绑定)调用(显示绑定) var bar = foo.call(obj); 3.函数是否在某个上下文对象中调用(隐式绑定) var bar = obj.foo(); 4.如果都不是的话,就使用默认绑定 var bar = foo();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github]]></title>
      <url>%2F2017%2F02%2F17%2Fgithub%2F</url>
      <content type="text"><![CDATA[学习Git 一、windows安装git下载链接 二、建立远程仓库1.创建SSH Key $ ssh-keygen -t rsa -C “Cybbin@Cybbin.com” 创建ssh key,一路回车默认即可创建.ssh目录,在该目录(我的是在C:\Users\Administrator目录下)下会有id_rsa,和id_rsa.pub文件id_rsa是私钥,不能泄露id_rsa.pub是公钥 2.登陆Github点击头像，打开Setting,点击左边的SSH and GPG keys,点击News SSH key填上任意Title,把id_rsa.pub的内容粘贴到Key文本框里然后点击Add SSH key 三、git指令提交仓库 git init git目录初始化 git add . 添加该目录下所有文件到暂存区 git commit -m ‘m’ 把文件提交到仓库,引号为提交的说明 git remote add origin git@github.com:Cybbin/jd.git 将本地仓库与Github仓库关联 git push -u origin master 将本地仓库推送到远程(Github)库的master主分支上-u是第一次提交时,把本地的master分支与远程的master分支关联起来在以后的推送就可以简化命令 git push origin master git clone git@github.com:Cybbin/jd.git 克隆远程库到本地,克隆在gitskills文件夹中 版本回退 git log 查看版本控制器的历史记录commit后面为版本id git log --pretty=oneline 前面为版本commit id,后面的数字为在commit的时候后面引号内的内容 git log --pretty=oneline --abbrev-commit 只显示前几位commit id git reset --hard HEAD^ 回到上个版本上上个版本是 Head^^上100个版本是 Head~100回到第id个版本,id为git log出现的commit id git reset --hard id git reflog 记录每一次命令的id回退时找不到新版本的id时用(重返未来) git status 查看当前仓库的状态 分支管理 git branch dev 创建dev分支 git checkout dev 切换到dev分支上 git checkout -b dev 相当于这两句 git branch devgit checkout dev git branch 列出所有分支,当前分支前有*号 git merge dev 将dev分支合并到master主分支上,Fast forward模式 git merge dev --no-ff -m ‘’ dev 禁用Fast forward模式，并提交备注信息 git branch -d dev 删除dev分支,没有被合并时,如果有修改,无法删除 git branch -D dev 强力删除dev分支 git log --graph 列出分支合并图 git stash 将当前工作现场隐藏 git stash list 列出当前分支所有被隐藏的工作区 git stash pop 恢复工作区,并删除stash内容 git stash apply stash@{0} 恢复工作区,但没有删除stash内容需要再用 git stash drop 来删除 git pull 将最新的提交从origin抓下来 标签管理 git tag v1.0 设置当前标签为v1.0 git tag 查看当前分支的所有标签(不是按时间顺序排列,按字母顺序排列) git tab v1.0 id 对当前分支的过去版本打标签,id为commit id(版本回退里有) git show v1.0 查看v1.0标签信息 git tag -d v1.0 删除本地的标签 git push origin :ref/tags/v1.0 删除推送到远程的标签 git push origin v1.0 推送标签到远程 git push origin --tags 一次性推送全部未推送到远程的标签 其它小命令 git remote -v 查看远程库的信息 ls 查看当前目录所有文件 touch README.md 创建 README.md 文件 rm README.md 删除 README.md 文件 四、踩过的坑 错误：git commit 后运行 git status出现 git commit On branch master nothing to commit, working tree clean解决办法:当前分支没有修改内容,可能是切换错分支了查看分支 git branch 错误： git push origin masterTo git@github.com:Cybbin/jd.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘git@github.com:Cybbin/jd.git’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details. 解决办法： git push -f origin master 错误： $ git push -u origin masterTo git@github.com:yangchao0718/cocos2d.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘git@github.com:yangchao0718/cocos2d.githint: Updates were rejected because the tip of your current branch is behinhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details. 解决办法：github上的README.md文件不在本地代码目录中 git pull --rebase origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之ajax]]></title>
      <url>%2F2017%2F02%2F01%2Fajax%2F</url>
      <content type="text"><![CDATA[ajax源码: 123456789101112131415161718192021222324252627282930if(window.XMLHttpRequest)&#123; xmlHttp = new XMLHttpRequest();&#125;else if(windoe.ActionXObject)&#123; var actionName = ['MSXML2.XMLHTTP','Microsoft.XMLHTTP']; for(var i=0;i&amp;lt;actionName.length;i++)&#123; try&#123; xmlHttp = new ActionXObject(actionName[i]); &#125;catch(e)&#123;&#125; &#125;&#125;if(!xmlHttp)&#123; console.log('xmlHttp对象创建失败');&#125;else&#123; xmlHttp.onreadystatechange=callback; //xmlHttp.open('get','url',true); xmlHttp.open('post','url',true); xmlHttp.setHeadRequest('Content-type','appplication/x-www-form-urlencode'); xmlHttp.send();&#125;function callback()&#123; if(xmlHttp.readyState)&#123; if(xmlHttp.status)&#123; var responseText = xmlHttp.responseText; //返回XML时 //var responseXML = xmlHtpp.responseXML; //返回json时 //responseText = eval('('+responseText+')'); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css水平垂直居中]]></title>
      <url>%2F2017%2F01%2F25%2Fcss%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[4种将一个绝对定位元素水平垂直居中的方法 css代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.wrapper &#123; height: 500px; position: relative; /*css3方法*/ /* justify-content:center;/子元素水平居中/ align-items:center;/子元素垂直居中/ display:flex; */&#125;/*Chrome,Firefox, Safari, Mobile Safari, IE8-10.*/.div1 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 0; right: 0; top: 0; bottom: 0; margin: auto; text-align: center;&#125;/*******兼容IE6,7,流行方法*******/.div2 &#123; width: 100px; height: 100px; position: absolute; background: blue; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125;/*不兼容IE8*/.div3 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 50%; top: 50%; /* -webkit-transform:translate(-50%,-50%); -ms-transform:translate(-50%,-50%); */ transform: translate(-50%, -50%);&#125;/*水平方向居中*/.div3 &#123; width: 100px; height: 100px; background: red; margin: 0 auto;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown]]></title>
      <url>%2F2017%2F01%2F25%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[md语法 1# 这是H1 效果： 这是H1 1## 这是H2 ## 效果： 这是H2 标记区块123&gt; 标记区块1标记区块1&gt; &gt; 标记区块2 效果： 标记区块1标记区块1 标记区块2 代码12345&lt;pre&gt;&lt;code&gt; var i=0; i++;&lt;/pre&gt;&lt;/code&gt;`print() ;` 效果： var i=0; i++;print() ; 列表无序列表123456789* Bird* McHale* Parish&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ul&gt; 效果： Bird McHale Parish BirdMcHaleParish 有序列表12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 效果： BirdMcHaleParish 分割线123***___--- 效果： 超链接12[点击预览](http://www.baidu.com)[点击预览](http://www.baidu.com "预览") 效果：点击预览点击预览 强调12*强调(斜体)***强调(加粗)** 效果：强调(斜体)强调(加粗) 图片1![Alt Text](/uploads/1.jpg) 效果： 代码高亮1var a=2; 表格12345678910111213141516171819|language |language_key||:--------:|:----------:||css |css ||C++ |cpp ||C# C |cpp ||Go |go ||HTTP |http ||Java |java ||Javascript|javascript ||JSON |json ||Less |less ||Markdown |markdown ||Matlab |matlab ||PHP |php ||Python |python ||Ruby |ruby ||SCSS |SCSS ||SQL |sql ||XML |xml | 效果： language language_key css css C++ cpp C# C cpp Go go HTTP http Java java Javascript javascript JSON json Less less Markdown markdown Matlab matlab PHP php Python python Ruby ruby SCSS SCSS SQL sql XML xml]]></content>
    </entry>

    
  
  
</search>
