<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[js学习之(原型)继承]]></title>
      <url>%2F2017%2F02%2F21%2Fentend%2F</url>
      <content type="text"><![CDATA[继承继承意味着复制操作，JavaScript(默认)不会复制对象属性。JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 创建一个关联对象12345678function Foo()&#123;&#125;function Bar()&#123;&#125;//ES6之前Bar.prototype = Object.prototype(Foo.prototype);//ES6Object.setPrototypeOf(Bar.prototype,Foo.prototype); Object.create()会创建一个新对象(这里指Bar.prototype)并把新对象内部的[[Prototype]]关联到指定的对象中(这里指Foo)。 171]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之对象]]></title>
      <url>%2F2017%2F02%2F20%2Fobject%2F</url>
      <content type="text"><![CDATA[对象及其用法 对象的定义 声明形式1234var obj=&#123; key1:value1, key2:value2&#125;; 构造形式12var obj = new Object();obj.key=value; 对象的类型 基本类型对象是JavaScript的基础，在JavaScrpit中一共有六种主要类型。 string boolean number null undefined object 内置对象一些基本类型对象的子类型，通常被成为内置对象。 String Number Boolean Object Function Array Date RegExp Error!!!在JavaScript中，它们只是一些内置函数，而不是类似于Java当中的类。!!!12345678910var str1 = "I am a string";console.log(typeof str1); // stringconsole.log(str1 instanceof String); // falsevar str2 = new String("I am a String");console.log(typeof str2); // objectconsole.log(str2 instanceof String); // true//检查str2对象Object.prototype.toString.call(str2); // [Object String] 对象的内容 访问对象的值12345var obj&#123; a : 2&#125;;console.log(obj.a); // 2console.log(obj["a"]); // 2 访问对象的值，需要使用 .操作符和[]操作符。.语法通常被成为属性访问，[]语法通常被成为键访问。 属性描述符ECMAScript5中定义了一个叫”属性描述符”的对象。123456789var obj=&#123;&#125;;Object.defineProperty(obj,"a"&#123; value:2, // 值 writable:true, // 是否可写 configurable:true, // 是否可配置 enumerable:true, // 是否可枚举 setter:function()&#123;&#125;, // 设置值 getter:function()&#123;&#125; // 获取值&#125;); Writablewritable 决定是否可以修改属性的值。123456789var obj = &#123;&#125;;Object.defineProperty(obj,"a",&#123; value:2, writable:false, configurable:true, enumerable:true&#125;);obj.a = 3;console.log(obj.a); // 2,无法修改值,在严格模式下会报TypeError错误 Configurable只要属性是可配置的，就可以使用defineProperty()方法来修改属性描述符12345678910111213141516171819202122var obj = &#123;&#125;;obj.a = 3;console.log(obj.a);Object.defineProperty(obj,"a",&#123; value:4, writable:true, configurable:false, writable:true&#125;);console.log(obj.a); // 4obj.a = 5;console.log(obj.a); // 5delete obj.a;console.log(obj.a); // 5，禁止删除这个属性Object.defineProperty(obj,"a",&#123; value:6, writable:true, configurable:true, writable:true&#125;); // TypeError,无法修改属性描述符 由此可见，把configurable修改为false是单向操作，无法撤销！ Enumerable控制对象的属性能否出现在属性枚举中，比如说for..in循环。12345678910111213141516var obj=&#123; a:2, b:3&#125;;for(let i in obj)&#123; console.log(i);&#125; // a bObject.defineProperty(obj,"a",&#123; value:2, writable:true, configurable:true, enumerable:false&#125;);for(let i in obj)&#123; console.log(i);&#125; // b Setter和Getter1234567891011121314var obj=&#123; get a()&#123; return this._a_; &#125; set a(value)&#123; this._a_ = value*2; &#125;&#125;;Object.defineProperty(obj,"b",&#123; get:function()&#123;return this.a*2&#125;,&#125;);obj.a=2;console.log(obj.a); // 4console.log(obj.b); // 8 禁止拓展禁止一个对象添属性并保留已有属性。123456var obj=&#123; a=2&#125;;Object.preventExtensions(obj); //禁止拓展obj.b=3;console.log(obj.b); // undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之this]]></title>
      <url>%2F2017%2F02%2F19%2Fthis%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》 绑定规则 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); // 2 默认绑定时,this指向全局对象。但是在严格模式下,全局对象无法使用默认绑定。123456function foo()&#123; "use strict"; console.log(this.a);&#125;var a=2;foo(); // Type Error:this is undefined 隐式绑定在一个对象内部创建包含一个指向函数的属性，并通过这个对象间接引用函数，从而把this隐式绑定到这个对象上。12345678function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;obj.f(); // 2 this绑定到obj对象 隐式丢失12345678910function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;var bar = obj.f;var a = "hello";bar(); // hello 隐式绑定的函数丢失绑定对象，应用默认绑定。 显式绑定使用 call() 和 apply() 方法，把this绑定到传进去的对象上1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a=2;&#125;foo.call(obj); // 2 与隐式绑定相同，显示绑定同样有着绑定丢失的情况但是显示绑定的一个变种可以解决这个问题 硬绑定12345678910function foo something(something)&#123; console.log(this.a,something); return this.a + something;&#125;var obj=&#123; a=2;&#125;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); //5 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar = new foo(2);console.log(bar.a); // 2 创建一个新对象并把它绑定到foo()调用的this上 优先级 显示绑定和隐式绑定12345678910111213141516function foo()&#123; console.log(this.a);&#125;var obj1=&#123; a:2, foo:foo&#125;;var obj2=&#123; a=3, foo:foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 可以看到，显示绑定优先级更高，在判断时应当先考虑是否可以应用显示绑定 new绑定和隐式绑定12345678910111213function foo(something)&#123; this.a=something;&#125;var obj1=&#123; foo:foo&#125;;obj1.foo(2);console.log(obj1.a); // 2var bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 可以看到，new绑定比隐式绑定优先级更高 new绑定和显示绑定123456789101112function foo(something)&#123; this.a=something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);consolo.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 可以看到，new绑定比显示绑定优先级更高 判断this顺序按照下面的顺序来判断this所应用的规则1.函数是否在用new中调用(new绑定) var bar = new foo(); 2.函数是否通过call、apply或者bind(硬绑定)调用(显示绑定) var bar = foo.call(obj); 3.函数是否在某个上下文对象中调用(隐式绑定) var bar = obj.foo(); 4.如果都不是的话,就使用默认绑定 var bar = foo();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github]]></title>
      <url>%2F2017%2F02%2F17%2Fgithub%2F</url>
      <content type="text"><![CDATA[学习Git 一、windows安装git下载链接 二、建立远程仓库1.创建SSH Key $ ssh-keygen -t rsa -C “Cybbin@Cybbin.com” 创建ssh,一路回车默认即可创建.ssh目录,在该目录(我的是在C:\Users\Administrator目录下)下会有id_rsa,和id_rsa.pub文件id_rsa是私钥,不能泄露id_rsa.pub是公钥 2.登陆Github点击头像，打开Setting,点击左边的SSH and GPG keys,点击News SSH key填上任意Title,把id_rsa.pub的内容粘贴到Key文本框里然后点击Add SSH key 三、git指令提交仓库 git init git目录初始化 git add . 添加该目录下所有文件到暂存区 git commit -m ‘m’ 把文件提交到仓库,引号为提交的说明 git remote add origin git@github.com:Cybbin/jd.git 将本地仓库与Github仓库关联 git push -u origin master 将本地仓库推送到远程(Github)库的master主分支上-u是第一次提交时,把本地的master分支与远程的master分支关联起来在以后的推送就可以简化命令 git push origin master git clone git@github.com:Cybbin/jd.git 克隆远程库到本地,克隆在gitskills文件夹中 版本回退 git log 查看版本控制器的历史记录commit后面为版本id git log —pretty=oneline 前面为版本commit id,后面的数字为在commit的时候后面引号内的内容 git log –pretty=oneline –abbrev-commit 只显示前几位commit id git reset –hard HEAD^ 回到上个版本上上个版本是 Head^^上100个版本是 Head~100回到第id个版本,id为git log出现的commit id git reset –hard id git reflog 记录每一次命令的id回退时找不到新版本的id时用(重返未来) git status 查看当前仓库的状态 分支管理 git branch dev 创建dev分支 git checkout dev 切换到dev分支上 git checkout -b dev 相当于这两句 git branch devgit checkout dev git branch 列出所有分支,当前分支前有*号 git merge dev 将dev分支合并到master主分支上,Fast forward模式 git merge dev –no-ff -m ‘’ dev 禁用Fast forward模式，并提交备注信息 git branch -d dev 删除dev分支,没有被合并时,如果有修改,无法删除 git branch -D dev 强力删除dev分支 git log –graph 列出分支合并图 git stash 将当前工作现场隐藏 git stash list 列出当前分支所有被隐藏的工作区 git stash pop 恢复工作区,并删除stash内容 git stash apply stash@{0} 恢复工作区,但没有删除stash内容需要再用 git stash drop 来删除 git pull 将最新的提交从origin抓下来 标签管理 git tag v1.0 设置当前标签为v1.0 git tag 查看当前分支的所有标签(不是按时间顺序排列,按字母顺序排列) git tab v1.0 id 对当前分支的过去版本打标签,id为commit id(版本回退里有) git show v1.0 查看v1.0标签信息 git tag -d v1.0 删除本地的标签 git push origin :ref/tags/v1.0 删除推送到远程的标签 git push origin v1.0 推送标签到远程 git push origin –tags 一次性推送全部未推送到远程的标签 其它小命令 git remote -v 查看远程库的信息 ls 查看当前目录所有文件 touch README.md 创建 README.md 文件 rm README.md 删除 README.md 文件 四、踩过的坑 错误：git commit 后运行 git status出现 git commit On branch master nothing to commit, working tree clean解决办法:当前分支没有修改内容,可能是切换错分支了查看分支 git branch 错误： git push origin masterTo git@github.com:Cybbin/jd.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘git@github.com:Cybbin/jd.git’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 解决办法： git push -f origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之ajax]]></title>
      <url>%2F2017%2F02%2F01%2Fajax%2F</url>
      <content type="text"><![CDATA[ajax源码: 123456789101112131415161718192021222324252627282930if(window.XMLHttpRequest)&#123; xmlHttp = new XMLHttpRequest();&#125;else if(windoe.ActionXObject)&#123; var actionName = ['MSXML2.XMLHTTP','Microsoft.XMLHTTP']; for(var i=0;i&amp;lt;actionName.length;i++)&#123; try&#123; xmlHttp = new ActionXObject(actionName[i]); &#125;catch(e)&#123;&#125; &#125;&#125;if(!xmlHttp)&#123; console.log('xmlHttp对象创建失败');&#125;else&#123; xmlHttp.onreadystatechange=callback; //xmlHttp.open('get','url',true); xmlHttp.open('post','url',true); xmlHttp.setHeadRequest('Content-type','appplication/x-www-form-urlencode'); xmlHttp.send();&#125;function callback()&#123; if(xmlHttp.readyState)&#123; if(xmlHttp.status)&#123; var responseText = xmlHttp.responseText; //返回XML时 //var responseXML = xmlHtpp.responseXML; //返回json时 //responseText = eval('('+responseText+')'); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css水平垂直居中]]></title>
      <url>%2F2017%2F01%2F25%2Fcss%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[4种将一个绝对定位元素水平垂直居中的方法 css代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.wrapper &#123; height: 500px; position: relative; /*css3方法*/ /* justify-content:center;/子元素水平居中/ align-items:center;/子元素垂直居中/ display:flex; */&#125;/*Chrome,Firefox, Safari, Mobile Safari, IE8-10.*/.div1 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 0; right: 0; top: 0; bottom: 0; margin: auto; text-align: center;&#125;/*******兼容IE6,7,流行方法*******/.div2 &#123; width: 100px; height: 100px; position: absolute; background: blue; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125;/*不兼容IE8*/.div3 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 50%; top: 50%; /* -webkit-transform:translate(-50%,-50%); -ms-transform:translate(-50%,-50%); */ transform: translate(-50%, -50%);&#125;/*水平方向居中*/.div3 &#123; width: 100px; height: 100px; background: red; margin: 0 auto;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown]]></title>
      <url>%2F2017%2F01%2F25%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[md语法 1# 这是H1 效果： 这是H1 1## 这是H2 ## 效果： 这是H2 标记区块123&gt; 标记区块1标记区块1&gt; &gt; 标记区块2 效果： 标记区块1标记区块1 标记区块2 代码12345&lt;pre&gt;&lt;code&gt; var i=0; i++;&lt;/pre&gt;&lt;/code&gt;`print() ;` 效果： var i=0; i++;print() ; 列表无序列表123456789* Bird* McHale* Parish&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ul&gt; 效果： Bird McHale Parish BirdMcHaleParish 有序列表12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 效果： BirdMcHaleParish 分割线123***___--- 效果： 超链接12[点击预览](http://www.baidu.com)[点击预览](http://www.baidu.com "预览") 效果：点击预览点击预览 强调12*强调(斜体)***强调(加粗)** 效果：强调(斜体)强调(加粗) 图片1![Alt Text](/uploads/1.jpg) 效果： 代码高亮1var a=2; 表格12345678910111213141516171819|language |language_key||:--------:|:----------:||css |css ||C++ |cpp ||C# C |cpp ||Go |go ||HTTP |http ||Java |java ||Javascript|javascript ||JSON |json ||Less |less ||Markdown |markdown ||Matlab |matlab ||PHP |php ||Python |python ||Ruby |ruby ||SCSS |SCSS ||SQL |sql ||XML |xml | 效果： language language_key css css C++ cpp C# C cpp Go go HTTP http Java java Javascript javascript JSON json Less less Markdown markdown Matlab matlab PHP php Python python Ruby ruby SCSS SCSS SQL sql XML xml]]></content>
    </entry>

    
  
  
</search>
