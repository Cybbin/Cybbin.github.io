<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Node.js]]></title>
      <url>%2F2017%2F03%2F12%2Fnodejs%2F</url>
      <content type="text"><![CDATA[记录Node.js的学习笔记 创建Node.js应用引入require模块使用require指令来载入模块1var http = require('http'); 创建服务器12345678910111213var http = require('http');http.createServer(function(request,response)&#123; // 发送 HTTP 头部 // HTTP 状态值：200：OK // 内容类型：text/plain response.writeHead(200,&#123;'Content-type':'text/plain'&#125;); // 发送数据 response.write('Hello world!'); response.end();&#125;).listen(8000);// 终端打印如下信息console.log('Server is running at http://localhost:8000/'); Node.js 回调函数 Node.js异步编程的直接体现就是回调。 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node使用了大量的回调函数，Node所有API都支持回调函数。例如，我们可以一边读取文件，一边执行其它命令，在文件读取完成后，将内容作为回调函数的参数返回。这样执行代码时就没有阻塞或等待I/O操作。这就大大提高了Node.js的性能，可以处理大量的并发要求。 阻塞代码实例12345var fs = require('fs');var data = fs.readFileSync('test.js');console.log('开始');console.log(data.toString());console.log('结束'); 非阻塞代码实例12345678var fs = require('fs');// 第一个参数为接受错误对象fs.readFile('test.js',function(err,data2)&#123; if(err) return console.log(err); console.log('开始'); console.log(data2.toString()); console.log('结束');&#125;); Node.js 事件循环Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序12345678910111213141516171819202122232425// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected()&#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;;// 绑定 connection 事件处理程序eventEmitter.on('connection',connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received',function()&#123; console.log('数据接受成功');&#125;);// 触发 connection 事件eventEmitter.emit('connection');console.log('程序执行完毕'); EventEmitterevents 模块只提供了一个对象：events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。你可以通过require(“events”);来访问该模块。123456789101112var eventEmitter = require('events').EventEmitter;var event = new eventEmitter();event.on('some_event',function(arg1,arg2)&#123; console.log('some_event1 事件触发',arg1,arg2);&#125;);event.on('some_event',function(arg1,arg2)&#123; console.log('some_event2 事件触发',arg1,arg2);&#125;);setTimeout(function()&#123; // 触发 some_event 事件 event.emit('some_event','参数1','参数2');&#125;,1000); 以上例子，emitter为事件some_event注册了两个事件监听器，然后触发了some_event事件EventEmitter的其中两个属性on和emit，on函数用于绑定事件函数，emit属性用于触发一个事件。12345678910111213141516171819202122232425262728293031323334var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 1var listener1 = function()&#123; console.log('监听器1执行');&#125;;// 监听器 2var listener2 = function()&#123; console.log('监听器2执行');&#125;;// 为指定事件添加一个监听器eventEmitter.addListener('connection',listener1);// 为指定事件注册一个监听器eventEmitter.on('connection',listener2);// 打印监听器的个数console.log(events.EventEmitter.listenerCount(eventEmitter,'connection')+"个监听器在监听");// 触发connection事件eventEmitter.emit('connection');// 移除监听器1eventEmitter.removeListener('connection',listener1);console.log('监听器1不再监听');// 打印监听器的个数console.log(events.EventEmitter.listenerCount(eventEmitter,'connection')+"个监听器在监听");// 触发connection事件eventEmitter.emit('connection');console.log('程序执行完毕'); 执行结果如下所示12345672个监听器在监听监听器1执行监听器2执行监听器1不再监听1个监听器在监听监听器2执行程序执行完毕 Node.js StreamStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 Node.js Stream有四种流类型 Readable - 可读操作Writable - 可写操作Duplex - 可写可读操作Transform - 操作被写入数据，然后读出结果 从流中读取数据123456789101112131415161718192021var fs = require('fs');var data = '';// 创建可读流var readerStream = fs.createReadStream('test.js');// 设置编码为utf8readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data,end,errorreaderStream.on('data',function(line)&#123; data+ =line;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log('读取完毕'); 写入流123456789101112131415161718192021var fs = require('fs');var data = '我要写入';// 创建写入流var writerStream = fs.createWriteStream('test.js');// 设置编码为utf8writerStream.write(data,'utf8');// 标记文件末尾writerStream.end();// 处理流事件writerStream.on('end',function()&#123; console.log('写入完成');&#125;);writerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log('程序执行结束'); 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。12345678910111213var fs = require("fs");// 创建一个可读流var readerStream = fs.createReadStream('hello.js');// 创建一个可写流var writerStream = fs.createWriteStream('test.js');// 管道读写操作// 读取 hello.js 文件内容，并将内容写入到 test.js 文件中readerStream.pipe(writerStream);console.log("程序执行完毕"); 链式流链式是通过连接输出流到另外一个流并创建爱你多个流操作链的机制。链式流一般用于管道操作。以下例子用管道和链式来压缩和解压文件。 压缩123456789var fs = require('fs');var zlib = require('zlib');// 压缩 test.js 为 test.zipfs.createReadStream('test.js') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('test.zip')); console.log('文件压缩完成'); 解压12345678var fs = require('fs');var zlib = require('zlib');// 压缩 test.zip 为 test.jsfs.createReadStream('test.zip') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('test.js'));console.log('文件解压完成'); Node.js 模块系统为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 创建模块创建test.js文件1234function fun()&#123; console.log('我是test.js exports的函数');&#125;exports.world = fun; 再创建hello.js12var test = require('./test.js');test.world(); 运行结果如下：1我是test.js exports的函数 test.js通过exports对象把world作为模块的访问接口，在hello.js中通过require(‘./test.js’)加载模块，然后就可以直接访问hello.js中exports对象的成员函数了。 模块加载; 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 从原生模块加载原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。require方法接受以下几种参数的传递： http、fs、path等，原生模块。./mod或../mod，相对路径的文件模块。/pathtomodule/mod，绝对路径的文件模块。mod，非原生模块的文件模块。 Node.js 路由server.js 服务器 12345678910111213var http = require('http');var url = require('url');function start(router)&#123; http.createServer(function(request,response)&#123; var pathname = url.parse(request.url).pathname; router(pathname); response.writeHead(200,&#123;'Content-type':'text/plain'&#125;); response.write(pathname); response.end(); &#125;).listen(8000); console.log('Server is running at http://localhost:8000');&#125;exports.start = start; router.js 路由 1234function router(pathname)&#123; console.log(pathname+'已被接收 by router');&#125;exports.router=router; index.js 将路由函数注入服务器 1234var server = require('./server.js');var router = require('./router.js');server.start(router.router);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试知识点]]></title>
      <url>%2F2017%2F03%2F12%2Finterview%2F</url>
      <content type="text"><![CDATA[记录牛客网刷的面试题 HTTP协议1.http是无状态的，2.request头 response3.状态码304表示 如果客户端发送了一个带GET请求且该请求已被允许，而文档的内容并没有改变（自上次访问以来或者根据请求的条件），则服务器应当返回这个状态码。307表示 临时重定向 1.简介HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP基于TCP/IP通信协议来传递数据。HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 2.特点（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。（2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。（3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 3.通信流程 4.消息结构HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息：请求行、请求头部、空行和请求数据。（requset） 1234GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi 服务端响应消息：状态行、消息报头、空行和响应正文。（response） 123456789HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: "34aa387-d-1568eb00" Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain 5.请求方法GET 请求指定的页面信息，并返回实体主体。HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT 从客户端向服务器传送的数据取代指定的文档的内容。DELETE 请求服务器删除指定的页面。CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS 允许客户端查看服务器的性能。TRACE 回显服务器收到的请求，主要用于测试或诊断。 6.状态码HTTP状态码分类1** 信息，服务器收到请求，需要请求者继续执行操作2** 成功，操作被成功接收并处理3** 重定向，需要进一步的操作以完成请求4** 客户端错误，请求包含语法错误或无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错HTTP状态码列表100 Continue 继续。客户端应继续其请求101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200 OK 请求成功。一般用于GET与POST请求201 Created 已创建。成功请求并创建了新的资源202 Accepted 已接受。已经接受请求，但未处理完成203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206 Partial Content 部分内容。服务器成功处理了部分GET请求300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303 See Other 查看其它地址。与301类似。使用GET和POST请求查看304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305 Use Proxy 使用代理。所请求的资源必须通过代理访问306 Unused 已经被废弃的HTTP状态码307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证402 Payment Required 保留，将来使用403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面405 Method Not Allowed 客户端请求中的方法被禁止406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408 Request Time-out 服务器等待客户端发送的请求时间过长，超时409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息412 Precondition Failed 客户端请求信息的先决条件错误413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417 Expectation Failed 服务器无法满足Expect的请求头信息500 Internal Server Error 服务器内部错误，无法完成请求501 Not Implemented 服务器不支持请求的功能，无法完成请求502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 HTML5HTML5新增标签article: 标签定义外部的内容。aside:标签定义 article 以外的内容。audio:h5新增音频标签。没有高宽属性。canvas:h5新增画布标签。command: 定义命令按钮(未测试)datalist：标签定义选项列表。details：标签用于描述文档或文档某个部分的细节。figure：标签用于对元素进行组合。figcaption：定义 figure 元素的标题。footer：定义 section 或 document 的页脚。header：定义 section 或 document 的页眉。hgroup：用于对网页或区段（section）的标题进行组合。keygen:标签规定用于表单的密钥对生成器字段mark：标签定义带有记号的文本。meter：通过min=”0” max=”20”的方式定义度量衡。仅用于已知最大和最小值的度量。nav：定义document或section或article的导航。output：定义不同的输出类型，比如脚本。progress：定义任何类型的任务的进度。rp:定义若浏览器不支持 ruby 元素显示的内容rt：定义 ruby 注释的解释ruby：定义 ruby 注释section：标签定义文档中的节、区段。比如章节、页眉、页脚或文档中的其他部分。source:audio和video的属性之一。为audio和video定义媒介源。summary:为details定义标题。time:定义日期或时间。video：h5新增视频标签。具有高宽属性。 HTML5的表单元素HTML5新的表单元素datalist : 规定输入域的选项列表，可以与input搭配使用，input的list属性值与daatlist的id值保持一致。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;body&gt; &lt;form action="/example/html5/demo_form.asp" method="get"&gt; Webpage: &lt;input type="url" list="url_list" name="link" /&gt; &lt;datalist id="url_list"&gt; &lt;option label="W3School" value="http://www.w3school.com.cn" /&gt; &lt;option label="Google" value="http://www.google.com" /&gt; &lt;option label="Microsoft" value="http://www.microsoft.com" /&gt; &lt;/datalist&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; keygen : 提供一种验证用户的可靠方法。keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。目前，浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准。12345678&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;body&gt; &lt;form action="/example/html5/demo_form.asp" method="get"&gt; &lt;keygen name="security" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; output : 用于不同类型的输出，比如计算或脚本输出。1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function resCalc()&#123; numA=document.getElementById("num_a").value; numB=document.getElementById("num_b").value; document.getElementById("result").value=Number(numA)+Number(numB); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;使用 output 元素的简易计算器：&lt;/p&gt; &lt;form onsubmit="return false"&gt; &lt;input id="num_a" /&gt; + &lt;input id="num_b" /&gt; = &lt;output id="result" onforminput="resCalc()"&gt;&lt;/output&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 栅格系统原理（Bootstrap）默认字体大小为14px 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; box-sizing:border-box; &#125; html,body&#123; width:100%; height:100%; &#125; .container&#123; width:704px; padding:0 15px; background:#eee; margin:0 auto; &#125; .row&#123; margin:0 -15px; background:#ccc; &#125; .col&#123; float:left; width:10%; height:50px; background:#aaa; margin:0 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script language=javascript&gt; &lt;/script&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之事件模型]]></title>
      <url>%2F2017%2F03%2F10%2Fjs-dom%2F</url>
      <content type="text"><![CDATA[一直对JavaScript中的事件模型不是很清楚，特此记录学习笔记 DOM事件流Dom(文档对象模型)结构是一个树形结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程称为DOM事件流。 事件顺序有两种类型：事件捕获和事件冒泡 冒泡型事件（Event Bubbling）这是IE浏览器对事件模型的实现，也是最容易理解的。冒泡，顾名思义，事件像水中的气泡一样往上冒，直到顶端。从DOM树形结构上理解，就是事件由具有从属关系的最确定的目标元素一直传递到最不确定的目标元素。即从当前元素一层一层往外知道最顶层。 捕获型事件（Event Capturing）与冒泡型刚好相反，由DOM树最顶层元素一直到最精确的元素。 标准的事件转送模式（1）.在事件捕捉（Capturing）阶段，事件将沿着DOM树向下转送，目标节点的每一个祖先节点，直至目标节点。例如，若用户单击了一个超链接，则该单击事件将从document节点转送到html元素，body元素以及包含该链接的p元素。在此过程中，浏览器都会检测针对该事件的捕捉事件监听器，并且运行这件事件监听器。(2). 在目标（target）阶段，浏览器在查找到已经指定给目标事件的事件监听器之后，就会运行 该事件监听器。目标节点就是触发事件的DOM节点。例如，如果用户单击一个超链接，那么该链接就是目标节点（此时的目标节点实际上是超链接内的文本节点）。（3）.在冒泡（Bubbling）阶段，事件将沿着DOM树向上转送，再次逐个访问目标元素的祖先节点到document节点。该过程中的每一步。浏览器都将检测那些不是捕捉事件监听器的事件监听器，并执行它们。 并非所有的事件都经过冒泡阶段所有的事件都要经过捕捉阶段和目标阶段，但是有些事件会跳过冒泡阶段，例如让元素获得输入焦点的focus事件和失去输入焦点的blur事件都不会冒泡。 事件句柄和事件监听器事件句柄事件句柄（又称事件处理函数，DOM称之为事件监听函数），用于响应某个事件而调用的函数称为事件处理函数。每一个事件对应一个句柄，响应点击事件的函数是onclick事件处理函数，可以分配在HTML和JavaScript中。 HTML1&lt;a href="#" onclick="click"&gt;click me!&lt;/a&gt; JavaSript1234var link = document.getElementById("mylink");link.onclick=function()&#123; dosomething();&#125;; 事件监听器现在大多数浏览器都内置了一些更高级的事件处理方式，即事件监听器，这种处理方式就不受一个元素只能绑定一个事件句柄的限制。事件句柄和事件监听器最大的不同就是在使用事件句柄时一次只能插接一个事件句柄，但对于事件监听器，一次可以插接多个。 IE下的事件监听器1element.attachEvent("onevent",eventListener); 在IE中想要给一个元素的事件附加事件处理函数，必须调用attachEvent方法才能创建一个事件监听器。attachEvent方法允许外界注册该元素多个事件监听器。attachEvent方法接受两个参数，第一个参数是事件类型名（’on’开头），第二个参数是回调处理函数。注意：IE中用attachEvent注册的处理函数调用this指向不再是先前注册事件的元素，此时的this为window对象。用detachEvent方法即可移除，参数相同。 DOM标准下的事件监听器1234//标准语法element.addEventListener('event',eventListener,useCapture);//默认element.addEventListener('event',eventListener,false); addEventListener方法接受三个参数，第一个参数是事件类型名（没’on’开头），第二个参数是回调处理函数，第三个参数注明该处理函数在事件传递过程中是否调用捕获阶段，通常设置为false（为false时是冒泡），如果设置为true，就创建爱你一个捕捉事件监听器。用removeEventListener方法即可移除，参数必须完全相同（包括useCapture的值）。 跨浏览器的注册与移除元素事件监听器12345678910111213141516171819202122var Event = &#123; //注册 addHandler:function(element,type,handle)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handle,false); &#125;else if(element.attachEvent)&#123; element.attachEvent("on"+type,handle); &#125;else &#123; element["on"+type] = handle; &#125; &#125;, //移除 removeHandle:function()&#123; if(element.remoeEventListener)&#123; element.removeEventListener(type,handle,false); &#125;else if(element.detachEvent)&#123; element.detachEvent("on"+type,handle); &#125;else &#123; element["on"+type] = null; &#125; &#125;&#125;; 事件对象引用为了可以更好地处理事件，可以根据所发生的事件的特定属性来采取不同的操作。与事件模型类似，IE使用一个event的全局事件对象来处理对象（可以在全局变量window.event来访问），其它浏览器采用的W3C推荐的方式，使用独立的包含事件对象的参数传递。 12345678var EventUtil=&#123; getEvent:function(event)&#123; return event?event:window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;&#125;; 停止事件冒泡和阻止事件的默认行为停止事件冒泡和祖师事件的默认行为这两个概念非常重要吗，它们对复杂的应用程序处理非常有用。 停止事件冒泡停止事件冒泡，指停止冒泡型事件的进一步传递。在冒泡型时间传递中，如果在body处理停止事件传递后，位于上层的document的事件监听器就不再收到通知，不再被处理。 IE下的停止事件冒泡123function someHandle()&#123; window.event.cancelBubble = true; // 取消冒泡&#125; DOM标准下的停止事件冒泡123function someHandle(event)&#123; event.stopPropagation();&#125; 跨浏览器的停止事件冒泡12345678function someHandle(event)&#123; event=event || window.event; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 停止事件的默认行为停止事件的默认行为，指通常浏览器在事件传递并处理完后会执行与该事件相关联的默认动作。例如，表单中input type的属性是”submit”，点击后在事件传播完后，浏览器就自动提交表单。又例如，input元素的keydown事件发生并树立后，浏览器默认会将用户键入的字符自动追加到input元素中。 IE下的停止事件的默认行为123function someHandle()&#123; window.event.returnValue = false;&#125; DOM标准下的停止事件的默认行为123function someHandle(event)&#123; event.preventDefault();&#125; 跨浏览器的停止时间的默认行为12345678function someHandle(event)&#123; event = event || window.event; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 完整的事件处理兼容性函数123456789101112131415161718192021222324252627282930313233343536373839404142434445var EventUtil=&#123; //添加事件 addHandler:function(element,type,handle)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handle.false); &#125;else if(element.attachEvent)&#123; element.attachEvent("on"+type,handle); &#125;else &#123; element["on"+type]=handle; &#125; &#125;, //移除事件 removeHandler:function(element,type,handle)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handle,false); &#125;else if(element.detachEvent)&#123; element.detachEvent("on"+type,handle); &#125;else &#123; element["on"+type]=null; &#125; &#125;, //获取事件对象 getEvent:function(event)&#123; return event?event:window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, //停止冒泡 stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else &#123; event.cancelBubble=true; &#125; &#125;, //停止事件的默认行为 preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else &#123; event.returnValue=false; &#125; &#125;&#125;; 捕获型事件模型与冒泡型事件模型的应用场合捕获型事件模型的应用场合捕获型事件传递由最不精确的祖先元素一直到最精确的事件源元素，传递方式与操作系统中的全局快捷键与应用程序快捷键相似。当一个系统组合键发生时，如果注册了系统全局快捷键监听器，该事件就先被操作系统层捕获，全局监听器就先于应用程序快捷键监听器得到通知，也就是全局的先获得控制权，它有权阻止事件的进一步传递。所以捕获型事件模型适用于作全局范围内的监听，这里的全局是相对的全局，相对于某个顶层结点与该结点所有子孙结点形成的集合范围。例如你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器。12345678function globalClickListener(event)&#123; if(canEventPass == false)&#123; //取消事件的进一步向子节点传递和冒泡传递 event.stopPropagation(); //取消浏览器事件后的默认行为 event.preventDefault(); &#125;&#125; 冒泡型事件模型的应用场合在元素一些频繁触发的事件中，如onmousemove,onmouseover,onmouseout,如果明确事件处理后没必要进一步传递，那么就可以大胆的取消它。此外，对于子结点事件监听器的处理会对父层监听器处理造成负面影响的，也应该在子结点监听器中禁止事件进一步向上传递以消除影响。 123456789&lt;body onclick="alert('current is body');"&gt; &lt;div id="div0" onclick="alert('current is '+this.id)"&gt; &lt;div id="div1" onclick="alert('current is '+this.id)"&gt; &lt;div id="div2" onclick="alert('current is '+this.id)"&gt; &lt;div id="event_source" onclick="alert('current is '+this.id)" style="height:200px;width:200px;background-color:red;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 点击event_source时无论是DOM标准还是IE，直接写在HTML里的监听处理函数是事件冒泡传递时调用的，由最里层一直往上传递，先后出现current is event_sourcecurrent is div2current is div1current is div0current is body 添加以下片段12345var div2 = document.getElementById("div2");EventUtil.addHandler(div2,'click',function(event)&#123; event=EventUtil.getEvent(); EventUtil.stopPropagation(event);&#125;,false); 点击出现current is event_sourcecurrent is div2 在支持DOM标准的浏览器中，添加以下代码123document.body.addEventListener('click',function()&#123; event.stopPropagation();&#125;,true);//在捕获型传递调用 以上代码中的监听函数由于是捕获型传递时被调用的,所以点击event_source后,虽然事件源是id为event_source的元素,但捕获型选传递,从最顶层开始,body节点监听函数先被调用,并且取消了事件进一步向下传递,所以只会出现current is body 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之(原型)继承]]></title>
      <url>%2F2017%2F02%2F21%2Fentend%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》继承意味着复制操作，JavaScript(默认)不会复制对象属性。JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 创建一个关联对象12345678function Foo()&#123;&#125;function Bar()&#123;&#125;//ES6之前Bar.prototype = Object.create(Foo.prototype);//ES6Object.setPrototypeOf(Bar.prototype,Foo.prototype); Object.create()会创建一个新对象(这里指Bar.prototype)并把新对象内部的[[Prototype]]关联到指定的对象中(这里指Foo)。 [[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其它对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之对象]]></title>
      <url>%2F2017%2F02%2F20%2Fobject%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》 对象的定义 声明形式1234var obj=&#123; key1:value1, key2:value2&#125;; 构造形式12var obj = new Object();obj.key=value; 对象的类型 基本类型对象是JavaScript的基础，在JavaScrpit中一共有六种主要类型。 string boolean number null undefined object 内置对象一些基本类型对象的子类型，通常被成为内置对象。 String Number Boolean Object Function Array Date RegExp Error!!!在JavaScript中，它们只是一些内置函数，而不是类似于Java当中的类。!!!12345678910var str1 = "I am a string";console.log(typeof str1); // stringconsole.log(str1 instanceof String); // falsevar str2 = new String("I am a String");console.log(typeof str2); // objectconsole.log(str2 instanceof String); // true//检查str2对象Object.prototype.toString.call(str2); // [Object String] 对象的内容 访问对象的值12345var obj&#123; a : 2&#125;;console.log(obj.a); // 2console.log(obj["a"]); // 2 访问对象的值，需要使用 .操作符和[]操作符。.语法通常被成为属性访问，[]语法通常被成为键访问。 属性描述符ECMAScript5中定义了一个叫”属性描述符”的对象。123456789var obj=&#123;&#125;;Object.defineProperty(obj,"a"&#123; value:2, // 值 writable:true, // 是否可写 configurable:true, // 是否可配置 enumerable:true, // 是否可枚举 setter:function()&#123;&#125;, // 设置值 getter:function()&#123;&#125; // 获取值&#125;); Writablewritable 决定是否可以修改属性的值。123456789var obj = &#123;&#125;;Object.defineProperty(obj,"a",&#123; value:2, writable:false, configurable:true, enumerable:true&#125;);obj.a = 3;console.log(obj.a); // 2,无法修改值,在严格模式下会报TypeError错误 Configurable只要属性是可配置的，就可以使用defineProperty()方法来修改属性描述符12345678910111213141516171819202122var obj = &#123;&#125;;obj.a = 3;console.log(obj.a);Object.defineProperty(obj,"a",&#123; value:4, writable:true, configurable:false, writable:true&#125;);console.log(obj.a); // 4obj.a = 5;console.log(obj.a); // 5delete obj.a;console.log(obj.a); // 5，禁止删除这个属性Object.defineProperty(obj,"a",&#123; value:6, writable:true, configurable:true, writable:true&#125;); // TypeError,无法修改属性描述符 由此可见，把configurable修改为false是单向操作，无法撤销！ Enumerable控制对象的属性能否出现在属性枚举中，比如说for..in循环。12345678910111213141516var obj=&#123; a:2, b:3&#125;;for(let i in obj)&#123; console.log(i);&#125; // a bObject.defineProperty(obj,"a",&#123; value:2, writable:true, configurable:true, enumerable:false&#125;);for(let i in obj)&#123; console.log(i);&#125; // b Setter和Getter1234567891011121314var obj=&#123; get a()&#123; return this._a_; &#125; set a(value)&#123; this._a_ = value*2; &#125;&#125;;Object.defineProperty(obj,"b",&#123; get:function()&#123;return this.a*2&#125;,&#125;);obj.a=2;console.log(obj.a); // 4console.log(obj.b); // 8 禁止拓展禁止一个对象添属性并保留已有属性。123456var obj=&#123; a=2&#125;;Object.preventExtensions(obj); //禁止拓展obj.b=3;console.log(obj.b); // undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之this]]></title>
      <url>%2F2017%2F02%2F19%2Fthis%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》 绑定规则 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); // 2 默认绑定时,this指向全局对象。但是在严格模式下,全局对象无法使用默认绑定。123456function foo()&#123; "use strict"; console.log(this.a);&#125;var a=2;foo(); // Type Error:this is undefined 隐式绑定在一个对象内部创建包含一个指向函数的属性，并通过这个对象间接引用函数，从而把this隐式绑定到这个对象上。12345678function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;obj.f(); // 2 this绑定到obj对象 隐式丢失12345678910function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;var bar = obj.f;var a = "hello";bar(); // hello 隐式绑定的函数丢失绑定对象，应用默认绑定。 显式绑定使用 call() 和 apply() 方法，把this绑定到传进去的对象上1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a=2;&#125;foo.call(obj); // 2 与隐式绑定相同，显示绑定同样有着绑定丢失的情况但是显示绑定的一个变种可以解决这个问题 硬绑定12345678910function foo something(something)&#123; console.log(this.a,something); return this.a + something;&#125;var obj=&#123; a=2;&#125;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); //5 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar = new foo(2);console.log(bar.a); // 2 创建一个新对象并把它绑定到foo()调用的this上 优先级 显示绑定和隐式绑定12345678910111213141516function foo()&#123; console.log(this.a);&#125;var obj1=&#123; a:2, foo:foo&#125;;var obj2=&#123; a=3, foo:foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 可以看到，显示绑定优先级更高，在判断时应当先考虑是否可以应用显示绑定 new绑定和隐式绑定12345678910111213function foo(something)&#123; this.a=something;&#125;var obj1=&#123; foo:foo&#125;;obj1.foo(2);console.log(obj1.a); // 2var bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 可以看到，new绑定比隐式绑定优先级更高 new绑定和显示绑定123456789101112function foo(something)&#123; this.a=something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);consolo.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 可以看到，new绑定比显示绑定优先级更高 判断this顺序按照下面的顺序来判断this所应用的规则1.函数是否在用new中调用(new绑定) var bar = new foo(); 2.函数是否通过call、apply或者bind(硬绑定)调用(显示绑定) var bar = foo.call(obj); 3.函数是否在某个上下文对象中调用(隐式绑定) var bar = obj.foo(); 4.如果都不是的话,就使用默认绑定 var bar = foo();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github]]></title>
      <url>%2F2017%2F02%2F17%2Fgithub%2F</url>
      <content type="text"><![CDATA[学习Git 一、windows安装git下载链接 二、建立远程仓库1.创建SSH Key $ ssh-keygen -t rsa -C “Cybbin@Cybbin.com” 创建ssh key,一路回车默认即可创建.ssh目录,在该目录(我的是在C:\Users\Administrator目录下)下会有id_rsa,和id_rsa.pub文件id_rsa是私钥,不能泄露id_rsa.pub是公钥 2.登陆Github点击头像，打开Setting,点击左边的SSH and GPG keys,点击News SSH key填上任意Title,把id_rsa.pub的内容粘贴到Key文本框里然后点击Add SSH key 三、git指令提交仓库 git init git目录初始化 git add . 添加该目录下所有文件到暂存区 git commit -m ‘m’ 把文件提交到仓库,引号为提交的说明 git remote add origin git@github.com:Cybbin/jd.git 将本地仓库与Github仓库关联 git push -u origin master 将本地仓库推送到远程(Github)库的master主分支上-u是第一次提交时,把本地的master分支与远程的master分支关联起来在以后的推送就可以简化命令 git push origin master git clone git@github.com:Cybbin/jd.git 克隆远程库到本地,克隆在gitskills文件夹中 版本回退 git log 查看版本控制器的历史记录commit后面为版本id git log --pretty=oneline 前面为版本commit id,后面的数字为在commit的时候后面引号内的内容 git log --pretty=oneline --abbrev-commit 只显示前几位commit id git reset --hard HEAD^ 回到上个版本上上个版本是 Head^^上100个版本是 Head~100回到第id个版本,id为git log出现的commit id git reset --hard id git reflog 记录每一次命令的id回退时找不到新版本的id时用(重返未来) git status 查看当前仓库的状态 分支管理 git branch dev 创建dev分支 git checkout dev 切换到dev分支上 git checkout -b dev 相当于这两句 git branch devgit checkout dev git branch 列出所有分支,当前分支前有*号 git merge dev 将dev分支合并到master主分支上,Fast forward模式 git merge dev --no-ff -m ‘’ dev 禁用Fast forward模式，并提交备注信息 git branch -d dev 删除dev分支,没有被合并时,如果有修改,无法删除 git branch -D dev 强力删除dev分支 git log --graph 列出分支合并图 git stash 将当前工作现场隐藏 git stash list 列出当前分支所有被隐藏的工作区 git stash pop 恢复工作区,并删除stash内容 git stash apply stash@{0} 恢复工作区,但没有删除stash内容需要再用 git stash drop 来删除 git pull 将最新的提交从origin抓下来 标签管理 git tag v1.0 设置当前标签为v1.0 git tag 查看当前分支的所有标签(不是按时间顺序排列,按字母顺序排列) git tab v1.0 id 对当前分支的过去版本打标签,id为commit id(版本回退里有) git show v1.0 查看v1.0标签信息 git tag -d v1.0 删除本地的标签 git push origin :ref/tags/v1.0 删除推送到远程的标签 git push origin v1.0 推送标签到远程 git push origin --tags 一次性推送全部未推送到远程的标签 其它小命令 git remote -v 查看远程库的信息 ls 查看当前目录所有文件 touch README.md 创建 README.md 文件 rm README.md 删除 README.md 文件 四、踩过的坑 错误：git commit 后运行 git status出现 git commit On branch master nothing to commit, working tree clean解决办法:当前分支没有修改内容,可能是切换错分支了查看分支 git branch 错误： git push origin masterTo git@github.com:Cybbin/jd.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘git@github.com:Cybbin/jd.git’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details. 解决办法： git push -f origin master 错误： $ git push -u origin masterTo git@github.com:yangchao0718/cocos2d.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘git@github.com:yangchao0718/cocos2d.githint: Updates were rejected because the tip of your current branch is behinhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details. 解决办法：github上的README.md文件不在本地代码目录中 git pull --rebase origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之ajax]]></title>
      <url>%2F2017%2F02%2F01%2Fajax%2F</url>
      <content type="text"><![CDATA[ajax源码: 123456789101112131415161718192021222324252627282930if(window.XMLHttpRequest)&#123; xmlHttp = new XMLHttpRequest();&#125;else if(windoe.ActionXObject)&#123; var actionName = ['MSXML2.XMLHTTP','Microsoft.XMLHTTP']; for(var i=0;i&amp;lt;actionName.length;i++)&#123; try&#123; xmlHttp = new ActionXObject(actionName[i]); &#125;catch(e)&#123;&#125; &#125;&#125;if(!xmlHttp)&#123; console.log('xmlHttp对象创建失败');&#125;else&#123; xmlHttp.onreadystatechange=callback; //xmlHttp.open('get','url',true); xmlHttp.open('post','url',true); xmlHttp.setHeadRequest('Content-type','appplication/x-www-form-urlencode'); xmlHttp.send();&#125;function callback()&#123; if(xmlHttp.readyState)&#123; if(xmlHttp.status)&#123; var responseText = xmlHttp.responseText; //返回XML时 //var responseXML = xmlHtpp.responseXML; //返回json时 //responseText = eval('('+responseText+')'); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css水平垂直居中]]></title>
      <url>%2F2017%2F01%2F25%2Fcss%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[4种将一个绝对定位元素水平垂直居中的方法 css代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.wrapper &#123; height: 500px; position: relative; /*css3方法*/ /* justify-content:center;/子元素水平居中/ align-items:center;/子元素垂直居中/ display:flex; */&#125;/*Chrome,Firefox, Safari, Mobile Safari, IE8-10.*/.div1 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 0; right: 0; top: 0; bottom: 0; margin: auto; text-align: center;&#125;/*******兼容IE6,7,流行方法*******/.div2 &#123; width: 100px; height: 100px; position: absolute; background: blue; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125;/*不兼容IE8*/.div3 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 50%; top: 50%; /* -webkit-transform:translate(-50%,-50%); -ms-transform:translate(-50%,-50%); */ transform: translate(-50%, -50%);&#125;/*水平方向居中*/.div3 &#123; width: 100px; height: 100px; background: red; margin: 0 auto;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown]]></title>
      <url>%2F2017%2F01%2F25%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[md语法 1# 这是H1 效果： 这是H1 1## 这是H2 ## 效果： 这是H2 标记区块123&gt; 标记区块1标记区块1&gt; &gt; 标记区块2 效果： 标记区块1标记区块1 标记区块2 代码12345&lt;pre&gt;&lt;code&gt; var i=0; i++;&lt;/pre&gt;&lt;/code&gt;`print() ;` 效果： var i=0; i++;print() ; 列表无序列表123456789* Bird* McHale* Parish&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ul&gt; 效果： Bird McHale Parish BirdMcHaleParish 有序列表12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 效果： BirdMcHaleParish 分割线123***___--- 效果： 超链接12[点击预览](http://www.baidu.com)[点击预览](http://www.baidu.com "预览") 效果：点击预览点击预览 强调12*强调(斜体)***强调(加粗)** 效果：强调(斜体)强调(加粗) 图片1![Alt Text](/uploads/1.jpg) 效果： 代码高亮1var a=2; 表格12345678910111213141516171819|language |language_key||:--------:|:----------:||css |css ||C++ |cpp ||C# C |cpp ||Go |go ||HTTP |http ||Java |java ||Javascript|javascript ||JSON |json ||Less |less ||Markdown |markdown ||Matlab |matlab ||PHP |php ||Python |python ||Ruby |ruby ||SCSS |SCSS ||SQL |sql ||XML |xml | 效果： language language_key css css C++ cpp C# C cpp Go go HTTP http Java java Javascript javascript JSON json Less less Markdown markdown Matlab matlab PHP php Python python Ruby ruby SCSS SCSS SQL sql XML xml]]></content>
    </entry>

    
  
  
</search>
