<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Linux安装Nodejs]]></title>
      <url>%2F2017%2F03%2F28%2Flinux-nodejs%2F</url>
      <content type="text"><![CDATA[服务器从Windows换到Linux， = =！！！，所有环境全部重装。 先在本机到Node.js官网下载Linux版的Node.js，32位、64位看清楚下载。 这里借助FileZilla工具，把下载好的压缩包上传到Linux服务器上。（PS：具体怎么传自行百度哈） Linux服务器上，在命令行输入：123tar -xvf nodejs.tar.gz // 解压。cd nodejs // 进入nodejs文件夹node -v // 查看版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js 爬虫小程序]]></title>
      <url>%2F2017%2F03%2F17%2Fspider%2F</url>
      <content type="text"><![CDATA[学习了Node.js后就照网上的教程，改编成爬取 深圳职业技术学院官网 的新闻数据和图片。 思路首先说下思路，登录官网后，每一篇新闻都有独一的链接，我们要做的就是进行一次请求，通过对网页的分析，将链接提取出来，然后再进行一次请求，爬取文章的内容和图片。 准备工作安装node.js下载地址 建立工程（1）在要创建项目的路径创建文件夹 cyb_spider; （2）在该目录下创建data文件夹（存放新闻）、image文件夹（存放图片）、spider.js文件; （3）打开cmd进入该目录; （4）npm init （初始化工程），一路回车即可，因为Node.js自带npm，所以无需专门去下载; （5）安装第三方包npm install cheerio --savecheerio 以一种类似jQuery的方式处理爬取的网页 npm install request --saverequest 简化http请求 npm install iconv-lite --saveiconv-lite 将gbk编码的网页转变为utf-8 --save是为了将项目对包的依赖写入package.json文件中 整个工程的目录结构为 代码准备工作大功告成，下面上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 获取模块var http = require('http'); fs = require('fs'); cheerio = require('cheerio'), request = require('request'), iconv = require('iconv-lite'), url = 'http://www.szpt.edu.cn/szyw/szyw/index.shtml'; // 官网url// 先爬取首页function pcindex(url,request,response)&#123; // 用 http 模块向服务器发起一次 get 请求 http.get(url,function(res)&#123; // 存储请求网页的完整 html 内容 var html = ''; res.setEncoding('binary'); // 监听 data 事件，获取网页内容 res.on('data',function(data)&#123; html+=data; &#125;); // 监听 end 事件，当网页完整获取完毕，就执行该函数 res.on('end',function()&#123; var buf = new Buffer(html,'binary'); html = iconv.decode(buf,'GBK'); // 解析html var $ = cheerio.load(html); // 获取标题 var title = $('.news_list li .title a'); // 获取时间 var date = $('.news_list li .data'); // 对 title 进行遍历 title.each(function(i,item)&#123; // 将标题和时间打印在网页上 response.write('标题：'+$(this).text()+'\n'); response.write('时间：'+date[i].children[0].data+'\n'); // 获取文章的链接 var link = $(this).attr('href'); // 对文章进行再次爬取 pc('http://www.szpt.edu.cn'+link,request,response); response.write('\n'); &#125;); &#125;); &#125;);&#125;// 获取每条新闻的链接后，请求链接并再次爬取function pc(url,req,response)&#123; http.get(url,function(res)&#123; var html =''; res.setEncoding('binary'); res.on('data',function(data)&#123; html+=data; &#125;); res.on('end',function()&#123; var buf = new Buffer(html,'binary'); html = iconv.decode(buf,'GBK'); var $ = cheerio.load(html); // 获取所有段落 var content = $('.news_list .content p'); // 获取标题 var title = $('.news_list .title'); // 存储文章的内容 var data=''; // 对段落进行遍历 content.each(function(index,item)&#123; // 将图片段落单独处理 if($(this).text().trim() == '')&#123; response.write('（图片）\n'); &#125;else&#123; var x = $(this).text().trim(); response.write(x+'\n'); // 对每个段落进行累加，\r\n 是为了能在文本文档中换行 data+=x+'\r\n'; &#125; &#125;); response.write('\n\n'); // 保存文本到本地文本文档 fs.appendFile('./data/'+title.text()+'.txt',data,'utf-8',function(err)&#123; if(err)&#123; console.log(err); &#125; &#125;); // 保存图片到本地 // 获取所有图片 var img = $('.news_list .content img'); if(img.length!==0)&#123; // 对图片进行遍历 img.each(function(index,item)&#123; // 获取图片链接 var img_link = 'http://www.szpt.edu.cn'+$(this).attr('src'); // 采用request模块，向服务器发送一次请求，获取图片资源并保存到本地 request(img_link).pipe(fs.createWriteStream('./image/'+title.text()+'---'+index+img_link.substr(img_link.length-4))); &#125;); &#125; &#125;); &#125;);&#125;// 创建服务器，http.createServer(function(request,response)&#123; if(request.url!='/favicon.ico')&#123; pcindex(url,request,response); &#125;&#125;).listen(8000);console.log('Server is running at http://localhost:8000/'); 在cmd运行 spider.js 程序1node spider.js 用浏览器http://localhost:8000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js]]></title>
      <url>%2F2017%2F03%2F12%2Fnodejs%2F</url>
      <content type="text"><![CDATA[记录Node.js的学习笔记 创建Node.js应用引入require模块使用require指令来载入模块1var http = require('http'); 创建服务器12345678910111213var http = require('http');http.createServer(function(request,response)&#123; // 发送 HTTP 头部 // HTTP 状态值：200：OK // 内容类型：text/plain response.writeHead(200,&#123;'Content-type':'text/plain'&#125;); // 发送数据 response.write('Hello world!'); response.end();&#125;).listen(8000);// 终端打印如下信息console.log('Server is running at http://localhost:8000/'); Node.js 回调函数 Node.js异步编程的直接体现就是回调。 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node使用了大量的回调函数，Node所有API都支持回调函数。例如，我们可以一边读取文件，一边执行其它命令，在文件读取完成后，将内容作为回调函数的参数返回。这样执行代码时就没有阻塞或等待I/O操作。这就大大提高了Node.js的性能，可以处理大量的并发要求。 阻塞代码实例12345var fs = require('fs');var data = fs.readFileSync('test.js');console.log('开始');console.log(data.toString());console.log('结束'); 非阻塞代码实例12345678var fs = require('fs');// 第一个参数为接受错误对象fs.readFile('test.js',function(err,data2)&#123; if(err) return console.log(err); console.log('开始'); console.log(data2.toString()); console.log('结束');&#125;); Node.js 事件循环Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序12345678910111213141516171819202122232425// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected()&#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;;// 绑定 connection 事件处理程序eventEmitter.on('connection',connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received',function()&#123; console.log('数据接受成功');&#125;);// 触发 connection 事件eventEmitter.emit('connection');console.log('程序执行完毕'); EventEmitterevents 模块只提供了一个对象：events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。你可以通过require(“events”);来访问该模块。123456789101112var eventEmitter = require('events').EventEmitter;var event = new eventEmitter();event.on('some_event',function(arg1,arg2)&#123; console.log('some_event1 事件触发',arg1,arg2);&#125;);event.on('some_event',function(arg1,arg2)&#123; console.log('some_event2 事件触发',arg1,arg2);&#125;);setTimeout(function()&#123; // 触发 some_event 事件 event.emit('some_event','参数1','参数2');&#125;,1000); 以上例子，emitter为事件some_event注册了两个事件监听器，然后触发了some_event事件EventEmitter的其中两个属性on和emit，on函数用于绑定事件函数，emit属性用于触发一个事件。12345678910111213141516171819202122232425262728293031323334var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 1var listener1 = function()&#123; console.log('监听器1执行');&#125;;// 监听器 2var listener2 = function()&#123; console.log('监听器2执行');&#125;;// 为指定事件添加一个监听器eventEmitter.addListener('connection',listener1);// 为指定事件注册一个监听器eventEmitter.on('connection',listener2);// 打印监听器的个数console.log(events.EventEmitter.listenerCount(eventEmitter,'connection')+"个监听器在监听");// 触发connection事件eventEmitter.emit('connection');// 移除监听器1eventEmitter.removeListener('connection',listener1);console.log('监听器1不再监听');// 打印监听器的个数console.log(events.EventEmitter.listenerCount(eventEmitter,'connection')+"个监听器在监听");// 触发connection事件eventEmitter.emit('connection');console.log('程序执行完毕'); 执行结果如下所示12345672个监听器在监听监听器1执行监听器2执行监听器1不再监听1个监听器在监听监听器2执行程序执行完毕 Node.js StreamStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 Node.js Stream有四种流类型 Readable - 可读操作Writable - 可写操作Duplex - 可写可读操作Transform - 操作被写入数据，然后读出结果 从流中读取数据123456789101112131415161718192021var fs = require('fs');var data = '';// 创建可读流var readerStream = fs.createReadStream('test.js');// 设置编码为utf8readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data,end,errorreaderStream.on('data',function(line)&#123; data+ =line;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log('读取完毕'); 写入流123456789101112131415161718192021var fs = require('fs');var data = '我要写入';// 创建写入流var writerStream = fs.createWriteStream('test.js');// 设置编码为utf8writerStream.write(data,'utf8');// 标记文件末尾writerStream.end();// 处理流事件writerStream.on('end',function()&#123; console.log('写入完成');&#125;);writerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log('程序执行结束'); 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。12345678910111213var fs = require("fs");// 创建一个可读流var readerStream = fs.createReadStream('hello.js');// 创建一个可写流var writerStream = fs.createWriteStream('test.js');// 管道读写操作// 读取 hello.js 文件内容，并将内容写入到 test.js 文件中readerStream.pipe(writerStream);console.log("程序执行完毕"); 链式流链式是通过连接输出流到另外一个流并创建爱你多个流操作链的机制。链式流一般用于管道操作。以下例子用管道和链式来压缩和解压文件。 压缩123456789var fs = require('fs');var zlib = require('zlib');// 压缩 test.js 为 test.zipfs.createReadStream('test.js') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('test.zip')); console.log('文件压缩完成'); 解压12345678var fs = require('fs');var zlib = require('zlib');// 压缩 test.zip 为 test.jsfs.createReadStream('test.zip') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('test.js'));console.log('文件解压完成'); Node.js 模块系统为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 创建模块创建test.js文件1234function fun()&#123; console.log('我是test.js exports的函数');&#125;exports.world = fun; 再创建hello.js12var test = require('./test.js');test.world(); 运行结果如下：1我是test.js exports的函数 test.js通过exports对象把world作为模块的访问接口，在hello.js中通过require(‘./test.js’)加载模块，然后就可以直接访问hello.js中exports对象的成员函数了。 模块加载; 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 从原生模块加载原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。require方法接受以下几种参数的传递： http、fs、path等，原生模块。./mod或../mod，相对路径的文件模块。/pathtomodule/mod，绝对路径的文件模块。mod，非原生模块的文件模块。 Node.js 路由server.js 服务器 12345678910111213var http = require('http');var url = require('url');function start(router)&#123; http.createServer(function(request,response)&#123; var pathname = url.parse(request.url).pathname; router(pathname); response.writeHead(200,&#123;'Content-type':'text/plain'&#125;); response.write(pathname); response.end(); &#125;).listen(8000); console.log('Server is running at http://localhost:8000');&#125;exports.start = start; router.js 路由 1234function router(pathname)&#123; console.log(pathname+'已被接收 by router');&#125;exports.router=router; index.js 将路由函数注入服务器 1234var server = require('./server.js');var router = require('./router.js');server.start(router.router); Node.js GET/POST请求表单提交到服务器一般使用GET/POST请求 获取 GET 请求内容12345678910var http = require('http');var url = require('url');var util = require('util');http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-type':'text/plain'&#125;); response.write(util.inspect(url.parse(request.url,true))); response.end();&#125;).listen(8000);console.log('Server is running at http://localhost:8000'); 在浏览器访问http://localhost:8000/user?haha=haha&amp;xixi=xixi查看返回结果12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?haha=haha&amp;xixi=xixi', query: &#123; haha: 'haha', xixi: 'xixi' &#125;, pathname: '/user', path: '/user?haha=haha&amp;xixi=xixi', href: '/user?haha=haha&amp;xixi=xixi' &#125; 获取URL的参数12345678910111213141516var http = require('http');var url = require('url');var util = require('util');http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-type':'text/plain'&#125;); //解析 url 参数 var params = url.parse(request.url,true.query); response.write('参数haha为：'+params.haha); response.write('\n'); response.write('参数xixi为：'+params.xixi); response.end();&#125;).listen(8000);console.log('Server is running at http://localhost:8000'); 在浏览器访问http://localhost:8000/user?haha=哈哈&amp;xixi=嘻嘻查看返回结果12参数haha为：哈哈参数xixi为：嘻嘻 获取 POST 请求内容POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。 123456789101112131415161718192021222324252627282930313233343536373839404142var http = require('http');var querystring = require('querystring');var html = '&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;' + '&lt;body&gt;' + '&lt;form method="post"&gt;' + '用户名： &lt;input name="username" type="text"&gt;&lt;br&gt;' + '密码： &lt;input name="password" type="password"&gt;&lt;br&gt;' + '&lt;input type="submit"&gt;' + '&lt;/form&gt;' + '&lt;/body&gt;&lt;/html&gt;'; http.createServer(function(request,response)&#123; // 定义一个post变量，用于暂村请求体的信息 var post=""; // 通过data事件监听函数，每当收到请求体的数据，就累加到post变量中 request.on('data',function(data)&#123; post+=data; &#125;); // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回 request.on('end',function()&#123; response.writeHead(200,&#123;'Content-type':'text-plain'&#125;); // 解析参数 post = querystring.parse(post); if(post.username &amp;&amp; post.password)&#123; // 输出POST的数据 response.write('用户名：'+post.username); response.write('\n'); response.write('密 码：'+post.password); &#125;else&#123; // 输出表单 response.write(html); &#125; response.end(); &#125;);&#125;).listen(8000);console.log('Server is running at http://localhost:8000');` Node.js Web 模块Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合。 创建 Web 服务器Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块。1var http = require('http'); 最基本的 HTTP 服务器架构（使用8080端口）12345678910111213141516171819202122232425var http = require('http');var fs = require('fs');var url = require('url');http.createServer(function(request,response)&#123; var pathname = url.parse(request.url).pathname.substr(1); console.log('请求'+pathname+"文件"); fs.readFile(pathname,function(err,data)&#123; if(err)&#123; console.log(err); // HTTP 状态码为 404 : NOT FOUND response.writeHead(404,&#123;'Content-type':'text/html'&#125;); response.write('找不到资源'); &#125;else&#123; // HTTP 状态码为 200 : OK response.writeHead(200,&#123;'Content-type':'text/html'&#125;); console.log('请求'+pathname+'成功'); // 响应文件内容 response.write(data); &#125; response.end(); &#125;);&#125;).listen(8080);console.log('Server is running at http://localhost:8080'); 在该目录下新建 index.html 文件123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是index.html页面 &lt;/body&gt;&lt;/html&gt; 在浏览器访问http://localhost:8000/index.html就会显示 index.html 页面。 创建 Web 客户端1234567891011121314151617var http = require('http');var body = &#123; host: 'localhost',// 一定不能加http port: 8080, path: '/index.html'&#125;;var callback = function(response)&#123; var body = ''; response.on( 'data', function (data) &#123; body+= data; &#125;); response.on( 'end', function () &#123; // 数据接受完成 console.log(body); &#125;);&#125;;http.request(body, callback).end(); Node.js Express 框架Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。Express 框架核心特性： 可以设置中间件来响应 HTTP 请求定义了路由表用于执行不同的 HTTP 请求动作可以通过向模版传递参数来动态渲染 HTML 页面 安装Express1npm install express -gd 第一个 Express 框架实例引入 express 模块，并在客户端发起请求后，响应 “Hello World” 字符串。12345678910111213var express = require('express');var app = express();app.get('/',function(request,response)&#123; response.send('Hello World!');&#125;);var server = app.listen(8080,function()&#123; var host = server.address().address; var port = server.address().port; &#125;); 在浏览器中访问 http://localhost:8080 请求和响应Express 应用使用回调函数的参数：request和response对象来处理请求和响应的数据。 Request对象request对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性，常见属性有： request.app - 当callback为外部文件时，用request.app访问express的实例request.baseUrl - 获取路由当前安装的URL路径request.body / req.cookies - 获得「请求主体」/ Cookiesrequest.fresh / req.stale - 判断请求是否还「新鲜」request.hostname / req.ip - 获取主机名和IP地址request.originalUrl - 获取原始请求URLrequest.params - 获取路由的parametersrequest.path - 获取请求路径request.protocol - 获取协议类型request.query - 获取URL的查询参数串request.route - 获取当前匹配的路由request.subdomains - 获取子域名request.accepts() - 检查可接受的请求的文档类型request.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages - 返回指定字符集的第一个可接受字符编码request.get() - 获取指定的HTTP请求头request.is() - 判断请求头Content-Type的MIME类型 Response对象response对象表示 HTTP 响应，即在接受到请求时向客户端发送的 HTTP 相应数据。 response.app - 同req.app一样response.append() - 追加指定HTTP头response.set() - 在res.append()后将重置之前设置的头response.cookie(name，value [，option]) - 设置Cookieopition - domain / expires / httpOnly / maxAge / path / secure / signedresponse.clearCookie() - 清除Cookieresponse.download() - 传送指定路径的文件response.get() - 返回指定的HTTP头response.json() - 传送JSON响应response.jsonp() - 传送JSONP响应response.location() - 只设置响应的Location HTTP头，不设置状态码或者close responseresponse.redirect() - 设置响应的Location HTTP头，并且设置状态码302response.send() - 传送HTTP响应response.sendFile(path [，options] [，fn]) - 传送指定路径的文件 -会自动根据文件extension设定Content-Typeresponse.set() - 设置HTTP头，传入object可以一次设置多个头response.status() - 设置HTTP状态码response.type() - 设置Content-Type的MIME类型 路由由决定了由谁(指定脚本)去响应客户端请求。在HTTP请求中，可以通过路由提取出请求的URL以及GET/POST参数。 添加功能来处理更多类型的 HTTP 请求12345678910111213141516171819202122232425262728293031323334var express = require('express');var app = express();// 主页输出'Hello world!'app.get('/',function(request,response)&#123; console.log('主页 GET 请求'); response.send('Hello GET!');&#125;);app.post('/',function(request,response)&#123; console.log('主页 POST 请求'); response.send('Hello POST!');&#125;);app.get('/del_user',function(request,response)&#123; console.log('/del_user 响应 DELETE 请求'); response.send('删除页面');&#125;);app.get('/list_user',function(requset,response)&#123; console.log('/list_user GET 请求'); response.send('用户列表页面');&#125;);app.get('/ab*cd',function(request,response)&#123; console.log('/ab*cd GET 请求'); response.send('正则匹配');&#125;);var server = app.listen(8000,function()&#123; var host = server.address().address; var port = server.address().port; console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;); 静态文件Express 提供了内置的中间件 express.static 来设置静态文件如：图片，CSS，JavaScript等。 在目录下新建一个 img 文件夹，放上一张 test.jpg 图片1234567891011var express = require('express');var app = express();// 在 img 目录下查找app.use(express.static('img'));app.get('/',function(request,response)&#123; response.send('Hello world');&#125;);app.listen(8000); 在浏览器访问http://localhost:8000/test.jpg GET 和 POST 方法GET 方法新建 index.html 文件12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="/process_get" method="GET"&gt; 用户名: &lt;input type="text" name="username"&gt;&lt;br&gt; 密 码: &lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 新建 server.js 文件123456789101112131415161718var express = require('express');var app = express(); app.get('/index.html',function (requset,response)&#123; response.sendFile( __dirname + "/index.html" );&#125;) app.get('/process_get',function (requset,response)&#123; // 输出 JSON 格式 var info = &#123; username:requset.query.username, password:requset.query.password &#125;; console.log(info); response.end(JSON.stringify(info));&#125;)app.listen(8000); 在浏览器访问http://localhost:8000/index.html POST 方法新建 index.html 文件12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="/process_post" method="POST"&gt; 用户名: &lt;input type="text" name="username"&gt;&lt;br&gt; 密 码: &lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 新建 server.js 文件12345678910111213141516171819202122var express = require('express');var app = express();var bodyParser = require('body-parser');// 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded(&#123;extended:false&#125;);app.get('/index.html',function(requset,response)&#123; response.sendFile(__dirname+"/index.html");&#125;);app.post('/process_post',urlencodedParser,function(request,response)&#123; //输出 JSON 格式 var info = &#123; username:request.body.username, password:request.body.password &#125;; console.log(info); response.end(JSON.stringify(info));&#125;);app.listen(8000); 在浏览器访问http://localhost:8000/index.html 文件上传创建一个用于上传控件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 选择一个文件上传&lt;br/&gt; &lt;form action="/file_upload" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="image" size="50"/&gt; &lt;br/&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; server.js123456789101112131415161718192021222324252627282930313233343536var express = require('express');var app = express();var fs = require('fs');var bodyParser = require('body-parser');var multer = require('multer');app.use(express.static('img'));app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(multer(&#123;dest:'/tmp/'&#125;).array('image'));app.get('/index.html',function(request,response)&#123; response.sendFile(__dirname+'/index.html');&#125;);app.post('/file_upload',function(request,response)&#123; // 上传的文件信息 console.log(request.files[0]); var path_file = __dirname+'/'+request.files[0].originalname; fs.readFile(request.files[0].path,function(err,data)&#123; fs.writeFile(path_file,data,function(err)&#123; if(err)&#123; console.log(err); &#125;else&#123; info = &#123; message:'File uploaded successfully !', filename:request.files[0].originalname &#125;; console.log(info); response.end(JSON.stringify(info)); &#125; &#125;); &#125;);&#125;);app.listen(8000); Cookie 管理使用中间件向 Node.js 服务器发送 cookie 信息1234567891011var express = require('express');var app = express();var cookieParser = require('cookie-parser');app.use(cookieParser());app.get('/',function(request,response)&#123; response.send('Cookies：'+request.cookies);&#125;);app.listen(8000); Node.js RESTful API什么是 REST ？EST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。 RESTful Web ServicesWeb service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。基于 REST 架构的 Web Services 即是 RESTful。由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。 创建RESTful新建一个 json 数据资源文件 user.json1234567891011121314151617181920&#123; &quot;user1&quot; : &#123; &quot;name&quot; : &quot;mahesh&quot;, &quot;password&quot; : &quot;password1&quot;, &quot;profession&quot; : &quot;teacher&quot;, &quot;id&quot;: 1 &#125;, &quot;user2&quot; : &#123; &quot;name&quot; : &quot;suresh&quot;, &quot;password&quot; : &quot;password2&quot;, &quot;profession&quot; : &quot;librarian&quot;, &quot;id&quot;: 2 &#125;, &quot;user3&quot; : &#123; &quot;name&quot; : &quot;ramesh&quot;, &quot;password&quot; : &quot;password3&quot;, &quot;profession&quot; : &quot;clerk&quot;, &quot;id&quot;: 3 &#125;&#125; 获取用户列表123456789101112var express = require('express');var app = express();var fs = require('fs');app.get('/listUsers',function(request,response)&#123; fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; console.log(data); response.end(data); &#125;);&#125;);app.listen(8000); 添加用户123456789101112131415161718192021222324var express = require('express');var app = express();var fs = require('fs');//添加新的用户信息var user = &#123; "user4" : &#123; "name" : "cyb", "password" : "123456", "profession" : "student", "id": 1 &#125;&#125;;app.get('/addUser',function(request,response)&#123; fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; data = JSON.parse(data); data["user4"]=user["user4"]; console.log(data); response.end(JSON.stringify(data)); &#125;);&#125;);app.listen(8000); 显示用户详情123456789101112131415var express = require('express');var app = express();var fs = require('fs');app.get('/:i',function(request,response)&#123; fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; data = JSON.parse(data); // 获取相应id的用户 var user = data["user"+request.params.i]; console.log(user); response.end(JSON.stringify(user)); &#125;);&#125;);app.listen(8000); 删除用户123456789101112131415var express = require('express');var app = express();var fs = require('fs');app.get('/deleteUser/:id',function(request,response)&#123; fs.readFile(__dirname+'/'+'users.json','utf8',function(err,data)&#123; data = JSON.parse(data); // 删除相应 id 的用户 delete data["user"+request.params.id]; console.log(data); response.end(JSON.stringify(data)); &#125;);&#125;);app.listen(8000);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试知识点]]></title>
      <url>%2F2017%2F03%2F12%2Finterview%2F</url>
      <content type="text"><![CDATA[记录面试题 HTTP协议1.http是无状态的，2.request头 response3.状态码304表示 如果客户端发送了一个带GET请求且该请求已被允许，而文档的内容并没有改变（自上次访问以来或者根据请求的条件），则服务器应当返回这个状态码。307表示 临时重定向 1.简介HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP基于TCP/IP通信协议来传递数据。HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 2.特点（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。（2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。（3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 3.通信流程 4.消息结构HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息：请求行、请求头部、空行和请求数据。（requset） 1234GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi 服务端响应消息：状态行、消息报头、空行和响应正文。（response） 123456789HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: "34aa387-d-1568eb00" Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain 5.请求方法GET 请求指定的页面信息，并返回实体主体。HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT 从客户端向服务器传送的数据取代指定的文档的内容。DELETE 请求服务器删除指定的页面。CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS 允许客户端查看服务器的性能。TRACE 回显服务器收到的请求，主要用于测试或诊断。 6.状态码HTTP状态码分类1** 信息，服务器收到请求，需要请求者继续执行操作2** 成功，操作被成功接收并处理3** 重定向，需要进一步的操作以完成请求4** 客户端错误，请求包含语法错误或无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错HTTP状态码列表100 Continue 继续。客户端应继续其请求101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200 OK 请求成功。一般用于GET与POST请求201 Created 已创建。成功请求并创建了新的资源202 Accepted 已接受。已经接受请求，但未处理完成203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206 Partial Content 部分内容。服务器成功处理了部分GET请求300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303 See Other 查看其它地址。与301类似。使用GET和POST请求查看304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305 Use Proxy 使用代理。所请求的资源必须通过代理访问306 Unused 已经被废弃的HTTP状态码307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证402 Payment Required 保留，将来使用403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面405 Method Not Allowed 客户端请求中的方法被禁止406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408 Request Time-out 服务器等待客户端发送的请求时间过长，超时409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息412 Precondition Failed 客户端请求信息的先决条件错误413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417 Expectation Failed 服务器无法满足Expect的请求头信息500 Internal Server Error 服务器内部错误，无法完成请求501 Not Implemented 服务器不支持请求的功能，无法完成请求502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 HTML5HTML5 新特性1.语义特性HTML5 赋予网页更好的意义和结构 2.本地存储特性基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度，这些得益于HTML5 APP Cache，以及本地存储功能。 3.设备访问特性从Geolocation功能的API文档公开以来，HTML5为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相连。 4.连接特性更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特效那个能够帮助我omen实现服务器将数据“推送”到客户端的功能。 5.网页多媒体特性支持网页端的Audio、Video等多媒体功能，与网站自带的APPS、摄像头、影音功能相得益彰。 6.三维、图像及特效特性基于SVG、Canvas、WebGL及CSS3的3D功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。 7.性能与集成特性HTML5通过XMLHttpRequest2等技术，解决以前的跨域等问题，帮助Web应用和网站在多样化的环境中更快速地工作。 HTML5 新增元素新图形绘制元素 标签 描述 canvas 定义图形，比如图标和其它图像。该标签基于JavaScript的绘图API 新多媒体元素 标签 描述 audio 定义音频内容 vedio 定义视频内容 source 定义多媒体资源（audio或vedio） embed 定义嵌入的内容，比如插件 track 为如vedio或audio元素之类的媒体规定外部文本轨道 新的表单元素datalist : 规定输入域的选项列表，可以与input搭配使用，input的list属性值与datalist的id值保持一致。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;body&gt; &lt;form action="/example/html5/demo_form.asp" method="get"&gt; Webpage: &lt;input type="url" list="url_list" name="link" /&gt; &lt;datalist id="url_list"&gt; &lt;option label="W3School" value="http://www.w3school.com.cn" /&gt; &lt;option label="Google" value="http://www.google.com" /&gt; &lt;option label="Microsoft" value="http://www.microsoft.com" /&gt; &lt;/datalist&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; keygen : 提供一种验证用户的可靠方法。keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。目前，浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准。12345678&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;body&gt; &lt;form action="/example/html5/demo_form.asp" method="get"&gt; &lt;keygen name="security" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; output : 用于不同类型的输出，比如计算或脚本输出。1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function resCalc()&#123; numA=document.getElementById("num_a").value; numB=document.getElementById("num_b").value; document.getElementById("result").value=Number(numA)+Number(numB); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;使用 output 元素的简易计算器：&lt;/p&gt; &lt;form onsubmit="return false"&gt; &lt;input id="num_a" /&gt; + &lt;input id="num_b" /&gt; = &lt;output id="result" onforminput="resCalc()"&gt;&lt;/output&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 新的语义和结构元素 标签 描述 article 定义页面独立的内容区域 aside 标签定义 article 以外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮。 details 用于描述文档或文档某个部分的细节 summary 定义 details 元素的标题 dialog 定义对话框，如提示框 figure 规定独立的流内容（图像、图标、照片、代码等） figcaption 定义 figure 元素的标题 footer 定义section 或 document 的页脚 header 定义文档的头部区域 hgroup 用于对网页或区段（section）的标题进行组合 mark 定义带有记号的文本 meter 通过min=”0” max=”20”的方式定义度量衡。仅用于已知最大和最小值的度量 nav 定义导航链接 progress 定义任何类型的任务的进度 ruby 定义ruby注释（中文注音或字符） rt 定义字符的解释或发音 rp 在ruby注释中使用，定义不支持ruby元素的浏览器所显示的内容 section 标签定义文档中的节、区段。比如章节、页眉、页脚或文档中的其他部分 time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 HTML5 移除元素 标签 acronym applet basefont big center dir font frame frameset noframes strike tt HTML5新标签兼容方法一：创建新标签123456789&lt;script&gt; (function()&#123; var e = "abbr, article, aside, audio, canvas, datalist, details, dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(','); var len=e.length; while(len--)&#123; document.createElement(e[i]); &#125; &#125;)();&lt;/script&gt; 方法二：使用框架123&lt;!--[if lt IE 9]&gt;&lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;&lt;![endif]--&gt; 栅格系统原理（Bootstrap）默认字体大小为14px 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; box-sizing:border-box; &#125; html,body&#123; width:100%; height:100%; &#125; .container&#123; width:704px; padding:0 15px; background:#eee; margin:0 auto; &#125; .row&#123; margin:0 -15px; background:#ccc; &#125; .col&#123; float:left; width:10%; height:50px; background:#aaa; margin:0 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script language=javascript&gt; &lt;/script&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 事件onabort：图像加载被中断onblur：元素失去焦点onchange：用户改变域的内容onclick：鼠标点击某个对象ondblclick：鼠标双击某个对象onerror：当加载文档或图像时发生某个错误onfocus：元素获得焦点onkeydown：某个键盘的键被按下onkeyprerss：某个键盘的键被按下或按住onkeyup：某个键盘的键被松开onload：某个页面或图像被完成加载onmousedown：某个鼠标按键被按下onmousemove：鼠标被移动onmouseout：鼠标从某元素移开onmouseover：鼠标被移到某元素之上onmouseup：某个鼠标按键被松开onreset：重置按钮被点击onresize：窗口或框架被调整尺寸onselect：文本被选定onsubmit：提交按钮被点击onunload：用户退出页面 DOM节点操作创建节点document.createElement()document.createElement()方法可以创建新元素，接收一个参数，即要创建元素的标签名，不区分大小写。所有节点都有一个ownerDocument的属性，指向整个文档节点document，使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性。123var newDiv = document.createElement("div");console.log(newDiv); // &lt;div&gt;console.log(newDiv.ownerDocument); // document 插入节点appendChild()appendChild()方法用于向childNodes列表的末尾添加一个节点，并返回新增节点。添加节点后，childNodes中的新增节点、父节点和以后的最后一个子节点的关系指针都响应地得到更新。（PS:如果插入的节点已经是文档的一部分，则将该结果从原来的位置转移到新位置(末尾)）12var newDiv =document.createElement("div");console.log(document.body.appendChild(newDiv)); // &lt;div&gt; insertBefore()insertBefore()方法接收两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点变成参照节点的前一个兄弟节点，并返回新增节点,如果参照节点是null,则插入在末尾。（PS:如果插入的节点已经是文档的一部分，则将该结果从原来的位置转移到新位置）12345678910&lt;div id="div0"&gt; &lt;div id="div1"&gt;div1&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var newDiv = document.createElement('div'); newDiv.innerHTML='newDiv'; var div0 = document.getElementById('div0'); var div1 = document.getElementById('div1'); console.log(div0.insertBefore(newDiv,div1)); // &lt;div&gt;newDiv&lt;/div&gt;&lt;/script&gt; insertAfter()由于不存在insertAfter()方法，如果要实现插在当前节点的某个子节点后面，可以用insertBefore()和appendChild()封装。1234567891011121314151617181920&lt;div id="div0"&gt; &lt;div id="div1"&gt;div1&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var newDiv = document.createElement('div'); newDiv.innerHTML='newDiv'; var div0 = document.getElementById('div0'); var div1 = document.getElementById('div1'); console.log(insertAfter(newDiv,div1)); // &lt;div&gt;newDiv&lt;/div&gt; function insertAfter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parent.lastChild==targetElement)&#123; targetElement.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125; return newElement; &#125;&lt;/script&gt; insertAdjacentHTML()insertAdjacentHTML()方法相当于前三个方法的综合，接收两个参数：插入位置和要插入的HTML文本。第一个参数为下列值之一： beforebeginafterbeginbeforeendafterend1234567891011121314&lt;div id='target' style="border: 1px solid black;"&gt;This is the element content&lt;/div&gt;&lt;button&gt;beforebegin&lt;/button&gt;&lt;button&gt;afterbegin&lt;/button&gt;&lt;button&gt;beforeend&lt;/button&gt;&lt;button&gt;afterend&lt;/button&gt;&lt;script&gt;var btns = document.getElementsByTagName('button');for(var i = 0 ; i &lt; 4; i++)&#123; btns[i].onclick = function()&#123; var that = this; target.insertAdjacentHTML(that.innerHTML,'&lt;span id="test"&gt;测试&lt;/span&gt;') &#125;&#125;&lt;/script&gt; 删除节点removeChild()removeChild()方法接收一个参数，即要移除的节点，并返回被移除的节点。1234567&lt;div id="myDiv"&gt;等待移除的节点&lt;/div&gt;&lt;button id="btn"&gt;移除节点&lt;/button&gt;&lt;script&gt;btn.onclick = function()&#123; removeChild(myDiv);&#125;&lt;/script&gt; remove()直接在要移除的节点使用remove()方法就可以移除该节点，无返回值。（PS:可用于删除元素节点和文本节点，但不可用于删除特性节点）1234567891011121314151617181920212223242526272829303132&lt;div id="div1"&gt;div1&lt;/div&gt;&lt;div id="div2" title='div2'&gt;div2（title=div2）&lt;/div&gt;&lt;div id="div3" title='div3'&gt;div3（title=div3）&lt;/div&gt;&lt;button id="btn1"&gt;remove div1&lt;/button&gt;&lt;button id="btn2"&gt;remove div2 title&lt;/button&gt;&lt;button id="btn3"&gt;remove div3&lt;/button&gt;&lt;script&gt; var btn1=document.getElementById('btn1'); var btn2=document.getElementById('btn2'); var btn3=document.getElementById('btn3'); btn1.onclick = function() &#123; //文本节点 console.log(div1.childNodes[0]); //'div1' div1.childNodes[0].remove(); &#125;; btn2.onclick = function() &#123; //特性节点 console.log(div2.attributes.title); //'div' //报错，remove()方法无法用于删除特性节点(title节点) try &#123; div2.attributes[0].remove(); &#125; catch(e) &#123; console.log('error'); &#125; &#125;; btn3.onclick = function() &#123; //元素节点 console.log(div3); // div3 div3.remove(); &#125;;&lt;/script&gt; 替换节点replaceChild()replaceChild()接收两个参数：要插入的节点和要被替换的节点。插入的节点将要被替换的节点替换掉。123456789101112131415&lt;div id="div1"&gt;1&lt;/div&gt;&lt;div id="div2"&gt;2&lt;/div&gt;&lt;div id="div3"&gt;3&lt;/div&gt;&lt;button id="btn1"&gt;新增节点替换(4替换2)&lt;/button&gt;&lt;button id="btn2"&gt;原有节点替换(3替换1)&lt;/button&gt;&lt;script&gt;btn2.onclick = function()&#123; document.body.replaceChild(div3,div1);&#125;btn1.onclick = function()&#123; var div4 = document.createElement('div'); div4.innerHTML = '4'; document.body.replaceChild(div4,div2);&#125;&lt;/script&gt; 复制节点cloneNode()cloneNode()方法用于克隆一个节点。它接收一个布尔值，表示是否深复制。当参数为true时，执行深复制，即复制节点和整个子节点树；当参数为false时，执行浅复制，即只复制节点本身。若参数为空，默认为false。(PS:复制的节点不会复制添加到DOM节点中的javascript属性，例如事件处理等，该方法只复制特性和子节点，其它一切都不会复制)123456789101112131415161718192021&lt;ul id="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var oList = document.getElementById('list'); oList.index = 0; var deepList = oList.cloneNode(true); //成功复制了子节点 console.log(deepList.children.length);//6 //但并没有复制属性 console.log(deepList.index);//undefined var shallowList = oList.cloneNode(); //浅复制不复制子节点 console.log(shallowList.children.length);//0&lt;/script&gt; cookies 和 session1.cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。 2.session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。 3.cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。 4.cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。 简单的说，当你登录一个网站的时候， 如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造，但是如果你能够获取某个登录用户的 sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性. 如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器 5.两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。 (1)cookie数据存放在客户的浏览器上，session数据放在服务器上(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中 浏览器内多个标签页之间的通信方法一：localstoragelocalstorage在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorage存储的值，实现不同标签页之间的通信。 标签页11234567891011&lt;input type="text" id="inp"&gt;&lt;input type="button" id="btn"&gt;&lt;script&gt; (function() &#123; var inp = document.getElementById("inp"); btn.onclick = function() &#123; var value = inp.value; localStorage.setItem("name", value); &#125;; &#125;)();&lt;/script&gt; 标签页21234567&lt;script&gt; (function()&#123; window.addEventListener('storage',function(event)&#123; console.log(event.key+"="+event.newValue); &#125;); &#125;)();&lt;/script&gt; 方法二：cookies+setInterval将要传递的信息存储在cookie中，每隔一定事件读取cookie信息，即可随时获取要传递的信息 标签页11234567891011&lt;input type="text" id="inp"&gt;&lt;input type="button" id="btn"&gt;&lt;script&gt; (function() &#123; var inp = document.getElementById("inp"); btn.onclick = function() &#123; var value = inp.value; document.cookie="name="+name; &#125;; &#125;)();&lt;/script&gt; 标签页212345678910&lt;script&gt; (function() &#123; function getCookie(key) &#123; return JSON.parse("&#123;\"" + document.cookie.replace(/;\s+/gim,"\",\"").replace(/=/gim, "\":\"") + "\"&#125;")[key]; &#125; setInterval(function()&#123; console.log("name=" + getCookie("name")); &#125;, 10000); &#125;)();&lt;/script&gt; JavaScriptJavaScript数据类型六种基本类型：String,Boolean,Number,null,undefined,symbol((es6引入) 七种数据类型：String,Boolean,Number,null,undefined,Object,Array typeof返回六种情况：String,Boolean,Number,undefined,Object,function JavaScript的基本规范 文件编码统一为utf-8 书写过程过, 每行代码结束必须有分号; 库引入: 原则上仅引入jQuery库 变量命名: 以下划线链接每个单词，类型_变量名s：表示字符串。n：表示数字。b：表示逻辑。a：表示数组。r：表示正则表达式。f：表示函数。o：表示以上未涉及到的其他对象， 常量：全部大写，以下划线分隔 如网站的URL，域,图片目录路径，js和css用到的目录路径 类命名: 首字母大写, 驼峰式命名. 如 Comment; 函数命名: 首字母小写驼峰式命名. 如getUserName(); 类中私有方法，以下划线+方法名标注,私有方法不能在类外被调用。 代码结构明了化, 加适量注释. 提高函数重用率; (1)大功能区块的功能描述(类，函数) 12345/*功能描述参数描述返回值*/ (2)单行的注释(放在行末尾) 1//注释 注重与html分离, 减小reflow, 注重性能. Dom中自定义的class，以j_classname的形式 把外部JavaScript文件放在HTML底部,的前面 优化循环(循环体中若有Dom操作，应该把Dom操作提到循环体外；在同一作用域内，Dom选择赋值给一局部变量。) 单引号和双引号为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号。 1&lt;img src="http://zywhunter.blog.163.com/blog/picture.gif" /&gt; 1document.write('&lt;p&gt;'); 12//一段混用的jQuery代码$('h1').after('&lt;div id="content"&gt;&lt;h2&gt;目录&lt;/h2&gt;&lt;ol&gt;&lt;/ol&gt;&lt;/div&gt;'); 使用更简单的格式来写innerscript 123456789//早期的代码可能是这样的&lt;script type="text/javascript" language="javascript"&gt;...&lt;/script&gt;//现在不用language属性了&lt;script type="text/javascript"&gt;...&lt;/script&gt; 总是检查数据要检查你的方法输入的所有数据，一方面是为了安全性，另一方面也是为了可用性。用户随时随地都会输入错误的数据。这不是因为他们蠢，而是因为他们很忙，并且思考的方式跟你不同。用typeof方法来检测你的function接受的输入是否合法。 避免混入其他技术,js不直接控制css详细的设置，可控制classname 避免全局变量全局变量和全局函数是非常糟糕的。因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。 12345//糟糕的全局变量和全局函数var current = null;function init()&#123;...&#125;function change()&#123;...&#125;function verify()&#123;...&#125; 解决办法有很多，Christian Heilmann建议的方法是： 12345678910111213141516171819202122//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。(function()&#123; var current = null; function init()&#123;...&#125; function change()&#123;...&#125; function verify()&#123;...&#125;&#125;)();//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据myNameSpace = function()&#123; var current = null; function init()&#123;...&#125; function change()&#123;...&#125; function verify()&#123;...&#125; //所有需要在命名空间外调用的函数和属性都要写在return里面 return&#123; init:init, //甚至你可以为函数和属性命名一个别名 set:change &#125;&#125;(); 声明变量的话，总是用varJavaScript中的变量可能是全局域或者局部域，用var声明的话会更加直观。 避免使用eval()方法(ajax数据请求验证)JavaScript中的eval()方法是在运行时把任何代码当作对象来计算/运行的方法。实际上由于安全性的缘故，大部分情况下都不应该用 eval()，总是有一种更“正确”的方法来完成同样的工作的。基本原则是，eval is evil，在任何时候都不要用它，除非你是一个老手，并且知道你不得不这样做。 不要偷懒省略”和{} 从技术上说，你可以忽略很多花括号和分号。 123456789//虽然看上去很不对头，大部分浏览器都能正确解析这段代码if(someVariableExists) x = false//这个代码看上去更不对头了，咋眼一看似乎下面的句都被执行了//实际上只有x=false在if中if(someVariableExists) x = false anotherFunctionCall(); 所以，要记住的原则是：1.永远不要省略分号；2.不要省略花括号，除非在同一行中。 12//这样是OK的if(2 + 2 === 4) return 'nicely done'; 获取对象属性的时候用方括号而不是点号在JavaScript中取得某对象的属性有两种方法： 12345//点号标记MyObject.property//方括号标记MyObject["property"] 如果是用点号标记取得对象的属性，属性名称是硬编码，无法在运行时更改；而用方括号的话，JavaScript会求得方括号内值然后通过计算结果来求得属性名。也就是说用方括号标记的方式，属性名称可以是硬编码的，也可以是变量或者函数返回值。 12345//这样是不行的MyObject.value+i//这样就没有问题MyObject["value"+i] for in语句遍历一个对象中的所有条目的时候，用for in语句是非常方便的。但有时候我们不需要遍历对象中的方法，如果不需要的话，可以加上一条filter。 123456//加上了一个过滤器的for in语句for(key in object) &#123; if(object.hasOwnProperty(key) &#123; ...then do something... &#125;&#125; 代码排版缩进 tab长度为4;行长度 ，控制在可视范围内，以一个分号结束;花括号,如果是一个代码段，花括号紧跟在语句的后面;文件功能定义。 CSS3新特性CSS3选择器（Selector） 选择器 例子 描述 element1~element2 p~ul 选择前面有 p 元素的每个 ul 元素 [attribute^=value] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 a 元素 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 a 元素 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 a 元素 :first-of-type p:first-of-type 选择属于其父元素的首个 p 元素的每个 p 元素 :last-of-type p:last-of-type 选择属于其父元素的最后 p 元素的每个 p 元素 :only-of-type p:only-of-type 选择属于其父元素唯一的 p 元素的每个 p 元素 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 p 元素 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 p 元素 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 p 元素的每个 p 元素 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数 :last-child p:last-child 选择属于其父元素最后一个子元素每个 p 元素 :root :root 选择文档的根元素 :empty p:empty 选择没有子元素的每个 p 元素（包括文本节点） :target #news:target 选择当前活动的 #news 元素 :enabled input:enabled 选择每个启用的 input 元素 :disabled input:disabled 选择每个禁用的 input 元素 :checked input:checked 选择每个被选中的 input 元素 :not(selector) :not(p) 选择非 p 元素的每个元素 ::selection ::selection 选择被用户选取的元素部分 Word-wrap &amp; Text-overflow 样式Word-wrap：允许长单词换行到下一行123456&lt;div style="width:296px; border:1px solid #999999; overflow: hidden"&gt; wordwrapbreakwordwordwrapbreakwordwordwrapbreakwordwordwrapbreakword&lt;/div&gt;&lt;div style="width:296px; border:1px solid #999999; word-wrap:break-word;"&gt; wordwrapbreakwordwordwrapbreakwordwordwrapbreakwordwordwrapbreakword&lt;/div&gt; Text-overflow： (1)text-overflow:clip; — 修剪文本 (2)text-overflow:ellipsis; — 显示省略符号来代表被修剪的文本 文字渲染（Text-decoration）12345div&#123; -webkit-text-fill-color:black; -webkit-text-stroke-color:red; -webkit-text-stroke-width:2.75px;&#125; Text-fill-color:文字内部填充颜色Text-stroke-color:文字边界填充颜色Text-stroke-width:文字边界宽度 多列布局（multi-column layout）1234567891011&lt;style&gt;multi_column_style&#123; -webkit-column-count:3; -webkit-column-rule:2px solid #bbb; -webkit-column-gap:20px;&#125;&lt;/style&gt;&lt;div class="multi_column_style"&gt; 测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本 测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本&lt;/div&gt; Column-count:表示布局几列Column-rule:表示列于列之间的间隔条样式Column-gap:表示列于列之间的间隔 边框和颜色（color border）颜色的透明度 1234color:rgba(255,0,0,0.5);background-color:rgba(255,0,0,0.5);color:hsla(112,72%,33%,0.68); 边框圆角 1border-radius:15px; 渐变效果线性渐变左上（0%，0%）到右上（0%，100%）即从左到右水平渐变1background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E)); 复杂线性渐变1background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),color-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E)); 径向渐变1234background: -webkit-gradient(radial,50 50,50,50 50,0,from(black),color-stop(0.5,red),to(blue));background: -webkit-gradient(radial,50 50,50,50 50,10,from(black),color-stop(0.5,red),to(blue));background: -webkit-gradient(radial,50 50,50,70 50,10,from(black),color-stop(0.5,red),to(blue));background: -webkit-gradient(radial,50 50,50,50 1,0,from(black),to(white)); 阴影（Shadow）和反射（Reflect）效果阴影（Shadow）12text-shadow:5px 2px 6px #ccc;box-shadow:5px 2px 6px #ccc; 四个参数：水平阴影距离，垂直阴影距离，模糊距离，颜色 反射（Reflect）1-webkit-box-reflect: below 1px; above：指定倒影在对象的上边below：指定倒影在对象的下边left：指定倒影在对象的左边right：指定倒影在对象的右边 Transition,Transform,Animation TransitionTransition (1)transition-property：用于指定过度的性质 (2)transition-duration：用于指定过度的持续时间 (3)transition-delay：用于指定延迟过度的时间 (4)transition-timing-function：用于指定过度类型（ease|linear|ease-in|ease-out|ease-in-out|cubic-bezier） 123456789101112&lt;style&gt; .transStart &#123; background-color: #fff; -webkit-transition: all .5s; -moz-transition: all .5s; transition: all .5s; &#125; .transStart:hover&#123; background-color: red; &#125;&lt;/style&gt;&lt;div id="transDiv" class="transStart"&gt; transition &lt;/div&gt; Transform1234567891011121314151617181920212223&lt;style&gt;.transStart&#123; -webkit-transition: all .5s; -moz-transition: all .5s; transition: all .5s; width:50px; height:50px; background:red;&#125;.skew&#123; -webkit-transform: skew(50deg); &#125;.scale&#123; -webkit-transform: scale(2, 0.5); &#125;.rotate&#123; -webkit-transform: rotate(30deg); &#125; .translate&#123; -webkit-transform: translate(50px, 50px); &#125;&lt;/style&gt;&lt;div id="transDiv" class="transStart"&gt;&lt;/div&gt; (1)skew：倾斜（角度） (2)scale：缩放（横向缩放，纵向缩放） (3)rotate：旋转（角度） (4)translate：平移（水平距离，纵向距离） Animation1234567891011121314151617181920&lt;style&gt;@-webkit-keyframes anim1 &#123; 0% &#123; Opacity: 0; Font-size: 12px; &#125; 100% &#123; Opacity: 1; Font-size: 24px; &#125;&#125;.anim1Div &#123; -webkit-animation-name: anim1; -webkit-animation-duration: 1.5s; -webkit-animation-iteration-count: 4; -webkit-animation-direction: alternate; -webkit-animation-timing-function: ease-in-out;&#125;&lt;/style&gt;&lt;div class="anim1Div"&gt;123&lt;/div&gt; (1)animation-name：定义动画名字 (2)animation-duration：定义动画时间 (3)animation-iteration-count：定义动画次数 (4)animation-direction：动画执行完一次后方向的变化方式（如第一次从右到左，第二次从左到右） (5)animation-function：变化的模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之事件模型]]></title>
      <url>%2F2017%2F03%2F10%2Fjs-dom%2F</url>
      <content type="text"><![CDATA[一直对JavaScript中的事件模型不是很清楚，特此记录学习笔记 DOM事件流Dom(文档对象模型)结构是一个树形结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程称为DOM事件流。 事件顺序有两种类型：事件捕获和事件冒泡 冒泡型事件（Event Bubbling）这是IE浏览器对事件模型的实现，也是最容易理解的。冒泡，顾名思义，事件像水中的气泡一样往上冒，直到顶端。从DOM树形结构上理解，就是事件由具有从属关系的最确定的目标元素一直传递到最不确定的目标元素。即从当前元素一层一层往外知道最顶层。 捕获型事件（Event Capturing）与冒泡型刚好相反，由DOM树最顶层元素一直到最精确的元素。 标准的事件转送模式（1）.在事件捕捉（Capturing）阶段，事件将沿着DOM树向下转送，目标节点的每一个祖先节点，直至目标节点。例如，若用户单击了一个超链接，则该单击事件将从document节点转送到html元素，body元素以及包含该链接的p元素。在此过程中，浏览器都会检测针对该事件的捕捉事件监听器，并且运行这件事件监听器。(2). 在目标（target）阶段，浏览器在查找到已经指定给目标事件的事件监听器之后，就会运行 该事件监听器。目标节点就是触发事件的DOM节点。例如，如果用户单击一个超链接，那么该链接就是目标节点（此时的目标节点实际上是超链接内的文本节点）。（3）.在冒泡（Bubbling）阶段，事件将沿着DOM树向上转送，再次逐个访问目标元素的祖先节点到document节点。该过程中的每一步。浏览器都将检测那些不是捕捉事件监听器的事件监听器，并执行它们。 并非所有的事件都经过冒泡阶段所有的事件都要经过捕捉阶段和目标阶段，但是有些事件会跳过冒泡阶段，例如让元素获得输入焦点的focus事件和失去输入焦点的blur事件都不会冒泡。 事件句柄和事件监听器事件句柄事件句柄（又称事件处理函数，DOM称之为事件监听函数），用于响应某个事件而调用的函数称为事件处理函数。每一个事件对应一个句柄，响应点击事件的函数是onclick事件处理函数，可以分配在HTML和JavaScript中。 HTML1&lt;a href="#" onclick="click"&gt;click me!&lt;/a&gt; JavaSript1234var link = document.getElementById("mylink");link.onclick=function()&#123; dosomething();&#125;; 事件监听器现在大多数浏览器都内置了一些更高级的事件处理方式，即事件监听器，这种处理方式就不受一个元素只能绑定一个事件句柄的限制。事件句柄和事件监听器最大的不同就是在使用事件句柄时一次只能插接一个事件句柄，但对于事件监听器，一次可以插接多个。 IE下的事件监听器1element.attachEvent("onevent",eventListener); 在IE中想要给一个元素的事件附加事件处理函数，必须调用attachEvent方法才能创建一个事件监听器。attachEvent方法允许外界注册该元素多个事件监听器。attachEvent方法接受两个参数，第一个参数是事件类型名（’on’开头），第二个参数是回调处理函数。注意：IE中用attachEvent注册的处理函数调用this指向不再是先前注册事件的元素，此时的this为window对象。用detachEvent方法即可移除，参数相同。 DOM标准下的事件监听器1234//标准语法element.addEventListener('event',eventListener,useCapture);//默认element.addEventListener('event',eventListener,false); addEventListener方法接受三个参数，第一个参数是事件类型名（没’on’开头），第二个参数是回调处理函数，第三个参数注明该处理函数在事件传递过程中是否调用捕获阶段，通常设置为false（为false时是冒泡），如果设置为true，就创建爱你一个捕捉事件监听器。用removeEventListener方法即可移除，参数必须完全相同（包括useCapture的值）。 跨浏览器的注册与移除元素事件监听器12345678910111213141516171819202122var Event = &#123; //注册 addHandler:function(element,type,handle)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handle,false); &#125;else if(element.attachEvent)&#123; element.attachEvent("on"+type,handle); &#125;else &#123; element["on"+type] = handle; &#125; &#125;, //移除 removeHandle:function()&#123; if(element.remoeEventListener)&#123; element.removeEventListener(type,handle,false); &#125;else if(element.detachEvent)&#123; element.detachEvent("on"+type,handle); &#125;else &#123; element["on"+type] = null; &#125; &#125;&#125;; 事件对象引用为了可以更好地处理事件，可以根据所发生的事件的特定属性来采取不同的操作。与事件模型类似，IE使用一个event的全局事件对象来处理对象（可以在全局变量window.event来访问），其它浏览器采用的W3C推荐的方式，使用独立的包含事件对象的参数传递。 12345678var EventUtil=&#123; getEvent:function(event)&#123; return event?event:window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;&#125;; 停止事件冒泡和阻止事件的默认行为停止事件冒泡和祖师事件的默认行为这两个概念非常重要吗，它们对复杂的应用程序处理非常有用。 停止事件冒泡停止事件冒泡，指停止冒泡型事件的进一步传递。在冒泡型时间传递中，如果在body处理停止事件传递后，位于上层的document的事件监听器就不再收到通知，不再被处理。 IE下的停止事件冒泡123function someHandle()&#123; window.event.cancelBubble = true; // 取消冒泡&#125; DOM标准下的停止事件冒泡123function someHandle(event)&#123; event.stopPropagation();&#125; 跨浏览器的停止事件冒泡12345678function someHandle(event)&#123; event=event || window.event; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 停止事件的默认行为停止事件的默认行为，指通常浏览器在事件传递并处理完后会执行与该事件相关联的默认动作。例如，表单中input type的属性是”submit”，点击后在事件传播完后，浏览器就自动提交表单。又例如，input元素的keydown事件发生并树立后，浏览器默认会将用户键入的字符自动追加到input元素中。 IE下的停止事件的默认行为123function someHandle()&#123; window.event.returnValue = false;&#125; DOM标准下的停止事件的默认行为123function someHandle(event)&#123; event.preventDefault();&#125; 跨浏览器的停止时间的默认行为12345678function someHandle(event)&#123; event = event || window.event; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 完整的事件处理兼容性函数123456789101112131415161718192021222324252627282930313233343536373839404142434445var EventUtil=&#123; //添加事件 addHandler:function(element,type,handle)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handle.false); &#125;else if(element.attachEvent)&#123; element.attachEvent("on"+type,handle); &#125;else &#123; element["on"+type]=handle; &#125; &#125;, //移除事件 removeHandler:function(element,type,handle)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handle,false); &#125;else if(element.detachEvent)&#123; element.detachEvent("on"+type,handle); &#125;else &#123; element["on"+type]=null; &#125; &#125;, //获取事件对象 getEvent:function(event)&#123; return event?event:window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, //停止冒泡 stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else &#123; event.cancelBubble=true; &#125; &#125;, //停止事件的默认行为 preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else &#123; event.returnValue=false; &#125; &#125;&#125;; 捕获型事件模型与冒泡型事件模型的应用场合捕获型事件模型的应用场合捕获型事件传递由最不精确的祖先元素一直到最精确的事件源元素，传递方式与操作系统中的全局快捷键与应用程序快捷键相似。当一个系统组合键发生时，如果注册了系统全局快捷键监听器，该事件就先被操作系统层捕获，全局监听器就先于应用程序快捷键监听器得到通知，也就是全局的先获得控制权，它有权阻止事件的进一步传递。所以捕获型事件模型适用于作全局范围内的监听，这里的全局是相对的全局，相对于某个顶层结点与该结点所有子孙结点形成的集合范围。例如你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器。12345678function globalClickListener(event)&#123; if(canEventPass == false)&#123; //取消事件的进一步向子节点传递和冒泡传递 event.stopPropagation(); //取消浏览器事件后的默认行为 event.preventDefault(); &#125;&#125; 冒泡型事件模型的应用场合在元素一些频繁触发的事件中，如onmousemove,onmouseover,onmouseout,如果明确事件处理后没必要进一步传递，那么就可以大胆的取消它。此外，对于子结点事件监听器的处理会对父层监听器处理造成负面影响的，也应该在子结点监听器中禁止事件进一步向上传递以消除影响。 123456789&lt;body onclick="alert('current is body');"&gt; &lt;div id="div0" onclick="alert('current is '+this.id)"&gt; &lt;div id="div1" onclick="alert('current is '+this.id)"&gt; &lt;div id="div2" onclick="alert('current is '+this.id)"&gt; &lt;div id="event_source" onclick="alert('current is '+this.id)" style="height:200px;width:200px;background-color:red;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 点击event_source时无论是DOM标准还是IE，直接写在HTML里的监听处理函数是事件冒泡传递时调用的，由最里层一直往上传递，先后出现current is event_sourcecurrent is div2current is div1current is div0current is body 添加以下片段12345var div2 = document.getElementById("div2");EventUtil.addHandler(div2,'click',function(event)&#123; event=EventUtil.getEvent(); EventUtil.stopPropagation(event);&#125;,false); 点击出现current is event_sourcecurrent is div2 在支持DOM标准的浏览器中，添加以下代码123document.body.addEventListener('click',function()&#123; event.stopPropagation();&#125;,true);//在捕获型传递调用 以上代码中的监听函数由于是捕获型传递时被调用的,所以点击event_source后,虽然事件源是id为event_source的元素,但捕获型选传递,从最顶层开始,body节点监听函数先被调用,并且取消了事件进一步向下传递,所以只会出现current is body 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之(原型)继承]]></title>
      <url>%2F2017%2F02%2F21%2Fentend%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》继承意味着复制操作，JavaScript(默认)不会复制对象属性。JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 创建一个关联对象12345678function Foo()&#123;&#125;function Bar()&#123;&#125;//ES6之前Bar.prototype = Object.create(Foo.prototype);//ES6Object.setPrototypeOf(Bar.prototype,Foo.prototype); Object.create()会创建一个新对象(这里指Bar.prototype)并把新对象内部的[[Prototype]]关联到指定的对象中(这里指Foo)。 [[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其它对象。 构造函数、原型、实例的关系：每个构造对象都有一个原型对象，原型对象包含一个指向构造函数的指针（prototype），而实例则包含一个指向原型对象的指针（proto）。 原型继承实现方式1.定义新的构造函数，并在内部用call()调用希望继承的构造函数，并绑定this；2.借助中间函数F实现原型继承，最好通过封装的Object.create()函数实现；3.继续在新的构造函数的原型上定义新方法。 12345678910111213141516171819202122232425262728293031323334353637383940// 父function Student(props)&#123; this.name=props.name||'Unnamed';&#125;Student.prototype.hello=function()&#123; console.log('Hello,'+this.name+'!');&#125;;// 子function PrimaryStudent(props)&#123; Student.call(this,props); this.grade=props.grade || 1;&#125; // 定义空函数，作桥接作用function F()&#123;&#125;// 把F的原型指向Student.prototypeF.prototype=Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototypePrimaryStudent.prototype=new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudentPrimaryStudent.prototype.constructor=PrimaryStudent; var xiaoming = new PrimaryStudent(&#123; name:'小明', grade:2&#125;); console.log(xiaoming.name);console.log(xiaoming.grade);// 验证原型console.log(xiaoming.__proto__===PrimaryStudent.prototype); // trueconsole.log(xiaoming.__proto__.__proto__===Student.prototype); // true // 验证继承关系console.log(xiaoming instanceof PrimaryStudent); // trueconsole.log(xiaoming instanceof Student); // true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之对象]]></title>
      <url>%2F2017%2F02%2F20%2Fobject%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》 对象的定义 声明形式1234var obj=&#123; key1:value1, key2:value2&#125;; 构造形式12var obj = new Object();obj.key=value; 对象的类型 基本类型对象是JavaScript的基础，在JavaScrpit中一共有六种主要类型。 string boolean number null undefined object 内置对象一些基本类型对象的子类型，通常被成为内置对象。 String Number Boolean Object Function Array Date RegExp Error!!!在JavaScript中，它们只是一些内置函数，而不是类似于Java当中的类。!!!12345678910var str1 = "I am a string";console.log(typeof str1); // stringconsole.log(str1 instanceof String); // falsevar str2 = new String("I am a String");console.log(typeof str2); // objectconsole.log(str2 instanceof String); // true//检查str2对象Object.prototype.toString.call(str2); // [Object String] 对象的内容 访问对象的值12345var obj&#123; a : 2&#125;;console.log(obj.a); // 2console.log(obj["a"]); // 2 访问对象的值，需要使用 .操作符和[]操作符。.语法通常被成为属性访问，[]语法通常被成为键访问。 属性描述符ECMAScript5中定义了一个叫”属性描述符”的对象。123456789var obj=&#123;&#125;;Object.defineProperty(obj,"a"&#123; value:2, // 值 writable:true, // 是否可写 configurable:true, // 是否可配置 enumerable:true, // 是否可枚举 setter:function()&#123;&#125;, // 设置值 getter:function()&#123;&#125; // 获取值&#125;); Writablewritable 决定是否可以修改属性的值。123456789var obj = &#123;&#125;;Object.defineProperty(obj,"a",&#123; value:2, writable:false, configurable:true, enumerable:true&#125;);obj.a = 3;console.log(obj.a); // 2,无法修改值,在严格模式下会报TypeError错误 Configurable只要属性是可配置的，就可以使用defineProperty()方法来修改属性描述符12345678910111213141516171819202122var obj = &#123;&#125;;obj.a = 3;console.log(obj.a);Object.defineProperty(obj,"a",&#123; value:4, writable:true, configurable:false, writable:true&#125;);console.log(obj.a); // 4obj.a = 5;console.log(obj.a); // 5delete obj.a;console.log(obj.a); // 5，禁止删除这个属性Object.defineProperty(obj,"a",&#123; value:6, writable:true, configurable:true, writable:true&#125;); // TypeError,无法修改属性描述符 由此可见，把configurable修改为false是单向操作，无法撤销！ Enumerable控制对象的属性能否出现在属性枚举中，比如说for..in循环。12345678910111213141516var obj=&#123; a:2, b:3&#125;;for(let i in obj)&#123; console.log(i);&#125; // a bObject.defineProperty(obj,"a",&#123; value:2, writable:true, configurable:true, enumerable:false&#125;);for(let i in obj)&#123; console.log(i);&#125; // b Setter和Getter1234567891011121314var obj=&#123; get a()&#123; return this._a_; &#125; set a(value)&#123; this._a_ = value*2; &#125;&#125;;Object.defineProperty(obj,"b",&#123; get:function()&#123;return this.a*2&#125;,&#125;);obj.a=2;console.log(obj.a); // 4console.log(obj.b); // 8 禁止拓展禁止一个对象添属性并保留已有属性。123456var obj=&#123; a=2&#125;;Object.preventExtensions(obj); //禁止拓展obj.b=3;console.log(obj.b); // undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之this]]></title>
      <url>%2F2017%2F02%2F19%2Fthis%2F</url>
      <content type="text"><![CDATA[参考《你不知道的JavaScript》 绑定规则 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); // 2 默认绑定时,this指向全局对象。但是在严格模式下,全局对象无法使用默认绑定。123456function foo()&#123; "use strict"; console.log(this.a);&#125;var a=2;foo(); // Type Error:this is undefined 隐式绑定在一个对象内部创建包含一个指向函数的属性，并通过这个对象间接引用函数，从而把this隐式绑定到这个对象上。12345678function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;obj.f(); // 2 this绑定到obj对象 隐式丢失12345678910function foo()&#123; console.log(this.a);&#125;var obj =&#123; a:2, f:foo&#125;var bar = obj.f;var a = "hello";bar(); // hello 隐式绑定的函数丢失绑定对象，应用默认绑定。 显式绑定使用 call() 和 apply() 方法，把this绑定到传进去的对象上1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a=2;&#125;foo.call(obj); // 2 与隐式绑定相同，显示绑定同样有着绑定丢失的情况但是显示绑定的一个变种可以解决这个问题 硬绑定12345678910function foo something(something)&#123; console.log(this.a,something); return this.a + something;&#125;var obj=&#123; a=2;&#125;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); //5 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar = new foo(2);console.log(bar.a); // 2 创建一个新对象并把它绑定到foo()调用的this上 优先级 显示绑定和隐式绑定12345678910111213141516function foo()&#123; console.log(this.a);&#125;var obj1=&#123; a:2, foo:foo&#125;;var obj2=&#123; a=3, foo:foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 可以看到，显示绑定优先级更高，在判断时应当先考虑是否可以应用显示绑定 new绑定和隐式绑定12345678910111213function foo(something)&#123; this.a=something;&#125;var obj1=&#123; foo:foo&#125;;obj1.foo(2);console.log(obj1.a); // 2var bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 可以看到，new绑定比隐式绑定优先级更高 new绑定和显示绑定123456789101112function foo(something)&#123; this.a=something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);consolo.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 可以看到，new绑定比显示绑定优先级更高 判断this顺序按照下面的顺序来判断this所应用的规则1.函数是否在用new中调用(new绑定) var bar = new foo(); 2.函数是否通过call、apply或者bind(硬绑定)调用(显示绑定) var bar = foo.call(obj); 3.函数是否在某个上下文对象中调用(隐式绑定) var bar = obj.foo(); 4.如果都不是的话,就使用默认绑定 var bar = foo();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github]]></title>
      <url>%2F2017%2F02%2F17%2Fgithub%2F</url>
      <content type="text"><![CDATA[学习Git 一、windows安装git下载链接 二、建立远程仓库1.创建SSH Key $ ssh-keygen -t rsa -C “Cybbin@Cybbin.com” 创建ssh key,一路回车默认即可创建.ssh目录,在该目录(我的是在C:\Users\Administrator目录下)下会有id_rsa,和id_rsa.pub文件id_rsa是私钥,不能泄露id_rsa.pub是公钥 2.登陆Github点击头像，打开Setting,点击左边的SSH and GPG keys,点击News SSH key填上任意Title,把id_rsa.pub的内容粘贴到Key文本框里然后点击Add SSH key 三、git指令提交仓库 git init git目录初始化 git add . 添加该目录下所有文件到暂存区 git commit -m ‘m’ 把文件提交到仓库,引号为提交的说明 git remote add origin git@github.com:Cybbin/jd.git 将本地仓库与Github仓库关联 git push -u origin master 将本地仓库推送到远程(Github)库的master主分支上-u是第一次提交时,把本地的master分支与远程的master分支关联起来在以后的推送就可以简化命令 git push origin master git clone git@github.com:Cybbin/jd.git 克隆远程库到本地,克隆在gitskills文件夹中 版本回退 git log 查看版本控制器的历史记录commit后面为版本id git log --pretty=oneline 前面为版本commit id,后面的数字为在commit的时候后面引号内的内容 git log --pretty=oneline --abbrev-commit 只显示前几位commit id git reset --hard HEAD^ 回到上个版本上上个版本是 Head^^上100个版本是 Head~100回到第id个版本,id为git log出现的commit id git reset --hard id git reflog 记录每一次命令的id回退时找不到新版本的id时用(重返未来) git status 查看当前仓库的状态 分支管理 git branch dev 创建dev分支 git checkout dev 切换到dev分支上 git checkout -b dev 相当于这两句 git branch devgit checkout dev git branch 列出所有分支,当前分支前有*号 git merge dev 将dev分支合并到master主分支上,Fast forward模式 git merge dev --no-ff -m ‘’ dev 禁用Fast forward模式，并提交备注信息 git branch -d dev 删除dev分支,没有被合并时,如果有修改,无法删除 git branch -D dev 强力删除dev分支 git log --graph 列出分支合并图 git stash 将当前工作现场隐藏 git stash list 列出当前分支所有被隐藏的工作区 git stash pop 恢复工作区,并删除stash内容 git stash apply stash@{0} 恢复工作区,但没有删除stash内容需要再用 git stash drop 来删除 git pull 将最新的提交从origin抓下来 标签管理 git tag v1.0 设置当前标签为v1.0 git tag 查看当前分支的所有标签(不是按时间顺序排列,按字母顺序排列) git tab v1.0 id 对当前分支的过去版本打标签,id为commit id(版本回退里有) git show v1.0 查看v1.0标签信息 git tag -d v1.0 删除本地的标签 git push origin :ref/tags/v1.0 删除推送到远程的标签 git push origin v1.0 推送标签到远程 git push origin --tags 一次性推送全部未推送到远程的标签 其它小命令 git remote -v 查看远程库的信息 ls 查看当前目录所有文件 touch README.md 创建 README.md 文件 rm README.md 删除 README.md 文件 四、踩过的坑 错误：git commit 后运行 git status出现 git commit On branch master nothing to commit, working tree clean解决办法:当前分支没有修改内容,可能是切换错分支了查看分支 git branch 错误： git push origin masterTo git@github.com:Cybbin/jd.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘git@github.com:Cybbin/jd.git’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details. 解决办法： git push -f origin master 错误： $ git push -u origin masterTo git@github.com:yangchao0718/cocos2d.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘git@github.com:yangchao0718/cocos2d.githint: Updates were rejected because the tip of your current branch is behinhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details. 解决办法：github上的README.md文件不在本地代码目录中 git pull --rebase origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之ajax]]></title>
      <url>%2F2017%2F02%2F01%2Fajax%2F</url>
      <content type="text"><![CDATA[ajax源码: 123456789101112131415161718192021222324252627282930if(window.XMLHttpRequest)&#123; xmlHttp = new XMLHttpRequest();&#125;else if(windoe.ActionXObject)&#123; var actionName = ['MSXML2.XMLHTTP','Microsoft.XMLHTTP']; for(var i=0;i&amp;lt;actionName.length;i++)&#123; try&#123; xmlHttp = new ActionXObject(actionName[i]); &#125;catch(e)&#123;&#125; &#125;&#125;if(!xmlHttp)&#123; console.log('xmlHttp对象创建失败');&#125;else&#123; xmlHttp.onreadystatechange=callback; //xmlHttp.open('get','url',true); xmlHttp.open('post','url',true); xmlHttp.setHeadRequest('Content-type','appplication/x-www-form-urlencode'); xmlHttp.send();&#125;function callback()&#123; if(xmlHttp.readyState)&#123; if(xmlHttp.status)&#123; var responseText = xmlHttp.responseText; //返回XML时 //var responseXML = xmlHtpp.responseXML; //返回json时 //responseText = eval('('+responseText+')'); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css水平垂直居中]]></title>
      <url>%2F2017%2F01%2F25%2Fcss%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[4种将一个绝对定位元素水平垂直居中的方法 css代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.wrapper &#123; height: 500px; position: relative; /*css3方法*/ /* justify-content:center;/子元素水平居中/ align-items:center;/子元素垂直居中/ display:flex; */&#125;/*Chrome,Firefox, Safari, Mobile Safari, IE8-10.*/.div1 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 0; right: 0; top: 0; bottom: 0; margin: auto; text-align: center;&#125;/*******兼容IE6,7,流行方法*******/.div2 &#123; width: 100px; height: 100px; position: absolute; background: blue; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125;/*不兼容IE8*/.div3 &#123; width: 100px; height: 100px; position: absolute; background: red; left: 50%; top: 50%; /* -webkit-transform:translate(-50%,-50%); -ms-transform:translate(-50%,-50%); */ transform: translate(-50%, -50%);&#125;/*水平方向居中*/.div3 &#123; width: 100px; height: 100px; background: red; margin: 0 auto;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown]]></title>
      <url>%2F2017%2F01%2F25%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[md语法 1# 这是H1 效果： 这是H1 1## 这是H2 ## 效果： 这是H2 标记区块123&gt; 标记区块1标记区块1&gt; &gt; 标记区块2 效果： 标记区块1标记区块1 标记区块2 代码12345&lt;pre&gt;&lt;code&gt; var i=0; i++;&lt;/pre&gt;&lt;/code&gt;`print() ;` 效果： var i=0; i++;print() ; 列表无序列表123456789* Bird* McHale* Parish&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ul&gt; 效果： Bird McHale Parish BirdMcHaleParish 有序列表12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 效果： BirdMcHaleParish 分割线123***___--- 效果： 超链接12[点击预览](http://www.baidu.com)[点击预览](http://www.baidu.com "预览") 效果：点击预览点击预览 强调12*强调(斜体)***强调(加粗)** 效果：强调(斜体)强调(加粗) 图片1![Alt Text](/uploads/1.jpg) 效果： 代码高亮1var a=2; 表格12345678910111213141516171819|language |language_key||:--------:|:----------:||css |css ||C++ |cpp ||C# C |cpp ||Go |go ||HTTP |http ||Java |java ||Javascript|javascript ||JSON |json ||Less |less ||Markdown |markdown ||Matlab |matlab ||PHP |php ||Python |python ||Ruby |ruby ||SCSS |SCSS ||SQL |sql ||XML |xml | 效果： language language_key css css C++ cpp C# C cpp Go go HTTP http Java java Javascript javascript JSON json Less less Markdown markdown Matlab matlab PHP php Python python Ruby ruby SCSS SCSS SQL sql XML xml]]></content>
    </entry>

    
  
  
</search>
